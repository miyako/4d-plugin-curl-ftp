/* --------------------------------------------------------------------------------
 #
 #    4DPlugin.cpp
 #    source generated by 4D Plugin Wizard
 #    Project : cURL FTP
 #    author : miyako
 #    2017/12/13
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

std::mutex mutexMcurl;
std::mutex mutexJson;

CURLM *gmcurl = NULL;

void OnStartup()
{
    curl_global_init(CURL_GLOBAL_DEFAULT);
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        gmcurl = curl_multi_init();
    }
}

void OnExit()
{
    if(gmcurl)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        curl_multi_cleanup(gmcurl);
        gmcurl = NULL;
    }
    
    curl_global_cleanup();
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
    try
    {
        PA_long32 pProcNum = selector;
        sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
        PackagePtr pParams = (PackagePtr)params->fParameters;
        
        CommandDispatcher(pProcNum, pResult, pParams);
    }
    catch(...)
    {
        
    }
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
    switch(pProcNum)
    {
        case kInitPlugin :
        case kServerInitPlugin :
            OnStartup();
            break;
            
        case kDeinitPlugin :
            OnExit();
            break;
            
            /*
             case kCloseProcess :
             OnCloseProcess();
             break;
             */
            // --- FTP
            
        case 1 :
            cURL_FTP_Delete(pResult, pParams);
            break;
            
        case 2 :
            cURL_FTP_GetDirList(pResult, pParams);
            break;
            
        case 3 :
            cURL_FTP_GetFileInfo(pResult, pParams);
            break;
            
        case 4 :
            cURL_FTP_MakeDir(pResult, pParams);
            break;
            
        case 5 :
            cURL_FTP_PrintDir(pResult, pParams);
            break;
            
        case 6 :
            cURL_FTP_Receive(pResult, pParams);
            break;
            
        case 7 :
            cURL_FTP_RemoveDir(pResult, pParams);
            break;
            
        case 8 :
            cURL_FTP_Rename(pResult, pParams);
            break;
            
        case 9 :
            cURL_FTP_Send(pResult, pParams);
            break;
            
        case 10 :
            cURL_FTP_System(pResult, pParams);
            break;
            
    }
}

// -------------------------------------- FTP -------------------------------------

#pragma mark -

CURLcode curl_perform(CURLM *mcurl, CURL *curl, C_TEXT& Param4, C_TEXT& userInfo)
{
    /* callback argument or return value if method name is empty */
    CUTF16String info;
    CURLMcode mc = CURLM_OK; /* not used to abort */
    CURLcode result = CURLE_OK;
    
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
    /* prepare for callback */
    PA_Variable    params[4];
    PA_long32 method_id = 0;//PA_GetMethodID((PA_Unichar *)Param4.getUTF16StringPtr());
    
    if(method_id)
    {
        params[0] = PA_CreateVariable(eVK_Unistring);
        params[1] = PA_CreateVariable(eVK_Unistring);
        params[2] = PA_CreateVariable(eVK_Undefined);
        params[3] = PA_CreateVariable(eVK_Undefined);
        PA_SetUnistring((&(params[1].uValue.fString)),
                        (PA_Unichar *)userInfo.getUTF16StringPtr());
    }else
    {
        params[0] = PA_CreateVariable(eVK_Unistring);
        params[1] = PA_CreateVariable(eVK_Boolean);
        params[2] = PA_CreateVariable(eVK_Unistring);
        params[3] = PA_CreateVariable(eVK_Unistring);
        PA_SetUnistring((&(params[0].uValue.fString)),
                        (PA_Unichar *)Param4.getUTF16StringPtr());
        PA_SetUnistring((&(params[3].uValue.fString)),
                        (PA_Unichar *)userInfo.getUTF16StringPtr());
    }
    int running_handles = 0;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        curl_multi_add_handle(mcurl, curl);
        curl_multi_perform(mcurl, &running_handles);
    }
    
    do
    {
        struct timeval tv;
        int rc = 0;
        
        fd_set fdread;
        fd_set fdwrite;
        fd_set fdexcep;
        
        int maxfd = -1;
        long curl_timeout = -1;
        
        FD_ZERO(&fdread);
        FD_ZERO(&fdwrite);
        FD_ZERO(&fdexcep);
        
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(mutexMcurl);
            
            curl_multi_timeout(mcurl, &curl_timeout);
            
            if(curl_timeout >= 0)
            {
                tv.tv_sec = curl_timeout / 1000;
                if(tv.tv_sec > 1)
                    tv.tv_sec = 1;
                else
                    tv.tv_usec = (curl_timeout % 1000) * 1000;
            }
            
            mc = curl_multi_fdset(mcurl, &fdread, &fdwrite, &fdexcep, &maxfd);
        }
        
        if(mc != CURLM_OK)
        {
            break;
        }
        
        if(maxfd == -1)
        {
            /* https://curl.haxx.se/libcurl/c/multi-post.html */
            PA_PutProcessToSleep2(currentProcessNumber, 6);//100ms
            rc = 0;
        }
        else
        {
            rc = select(maxfd+1, &fdread, &fdwrite, &fdexcep, &tv);
        }
        switch(rc) {
            case -1:
                /* select error */
                break;
            case 0:
            default:
                if(1)
                {
                    std::lock_guard<std::mutex> lock(mutexMcurl);
                    
                    /* timeout or readable/writable sockets */
                    mc = curl_multi_perform(mcurl, &running_handles);
                    /* callback method */
                }
                
            {
                if(Param4.getUTF16Length())
                {
                    if(1)
                    {
                        std::lock_guard<std::mutex> lock(mutexMcurl);
                        
                        curl_get_info(curl, info);
                    }
                    
                    if(method_id)
                    {
                        PA_SetUnistring((&(params[0].uValue.fString)),
                                        (PA_Unichar *)info.c_str());
                        
                        PA_Variable statusCode = PA_ExecuteMethodByID(method_id, params, 2);
                        if(PA_GetVariableKind(statusCode) == eVK_Boolean)
                        {
                            if(PA_GetBooleanVariable(statusCode))
                            {
                                /* abort */
                                result = CURLE_ABORTED_BY_CALLBACK;
                                goto curl_abort_transfer;
                            }
                        }
                    }else
                    {
                        PA_SetUnistring((&(params[2].uValue.fString)),
                                        (PA_Unichar *)info.c_str());
                        
                        PA_SetBooleanVariable(&params[1], false);
                        PA_ExecuteCommandByID(1007, params, 4);
                        if(PA_GetBooleanVariable(params[1]))
                        {
                            /* abort */
                            result = CURLE_ABORTED_BY_CALLBACK;
                            goto curl_abort_transfer;
                        }
                    }
                    
                }
                
                if(PA_IsProcessDying2())
                {
                    /* abort (runtime explorer, not debugger) */
                    result = CURLE_ABORTED_BY_CALLBACK;
                    goto curl_abort_transfer;
                }
                
            }
                break;
        }
        
    }while((running_handles));
    
curl_abort_transfer:
    
    PA_ClearVariable(&params[0]);
    PA_ClearVariable(&params[1]);
    PA_ClearVariable(&params[2]);
    PA_ClearVariable(&params[3]);
    
    struct CURLMsg *m;
    int msgq = 0;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        m = curl_multi_info_read(mcurl, &msgq);
        if(m && (m->msg == CURLMSG_DONE))
        {
            result = m->data.result;
        }
        
        if(!Param4.getUTF16Length())
        {
            curl_get_info(curl, info);
            Param4.setUTF16String(&info);
        }
        
        curl_multi_remove_handle(mcurl, curl);
    }
    
    return result;
}

#pragma mark -

void cURL_FTP_Delete(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path, TRUE);
    
    curl_unescape_path(curl, path);
    
    CUTF8String fullpath = path;
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    struct curl_slist *h = NULL;
    
    last_path_component(path);/* because we use CURLOPT_POSTQUOTE */
    
    CUTF8String quote;
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            quote = CUTF8String((const uint8_t *)"rm /").append(fullpath);/* rm takes an absolute path */
            break;
            
        default:
            quote = CUTF8String((const uint8_t *)"DELE ").append(path);/* the file name has been removed from the url in curl_set_options */
            break;
    }
    
    NSLog(@"%s", quote.c_str());
    
    h = curl_slist_append(h, (const char *)quote.c_str());
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            curl_easy_setopt(curl, CURLOPT_QUOTE, h);
            break;
            
        default:
            curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
            break;
    }
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param2, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param2.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);
}

void cURL_FTP_MakeDir(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_LONGINT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path);
    
    curl_unescape_path(curl, path);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    struct curl_slist *h = NULL;
    
    if(Param2.getIntValue())
    {
        curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, CURLFTP_CREATE_DIR_RETRY);
    }
    
    CUTF8String quote;
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            quote = CUTF8String((const uint8_t *)"mkdir ").append(path);
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
            
        default:
            quote = CUTF8String((const uint8_t *)"MKD ").append(path);
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
    }
    
    curl_easy_setopt(curl, CURLOPT_QUOTE, h);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param3.toParamAtIndex(pParams, 3);
    returnValue.setReturn(pResult);
}

void cURL_FTP_RemoveDir(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path);
    
    curl_unescape_path(curl, path);
    
    CUTF8String fullpath = path;
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    struct curl_slist *h = NULL;
    
    last_path_component(path);/* because we CURLOPT_POSTQUOTE */
    
    CUTF8String quote;
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            quote = CUTF8String((const uint8_t *)"rmdir ").append(fullpath + (const uint8_t *)"/");
            h = curl_slist_append(h, (const char *)quote.c_str());
            
            break;
            
        default:
            quote = CUTF8String((const uint8_t *)"RMD ").append(path);
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
    }
    
    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param2, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param2.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);
}

void cURL_FTP_Rename(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path);
    
    curl_unescape_path(curl, path);
    
    CUTF8String fullpath = path;
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    struct curl_slist *h = NULL;
    
    last_path_component(path);
    
    remove_trailing_separator(path);
    
    CUTF8String name;
    Param2.copyUTF8String(&name);
    
    CUTF8String quote;
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            quote = CUTF8String((const uint8_t *)"rename ")
            .append(fullpath)
            .append((const uint8_t *)" ")
            .append(name);
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
            
        default:
            quote = CUTF8String((const uint8_t *)"RNFR ").append(path);
            h = curl_slist_append(h, (const char *)quote.c_str());
            
            quote = CUTF8String((const uint8_t *)"RNTO ").append(name);
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
    }
    
    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param3.toParamAtIndex(pParams, 3);
    returnValue.setReturn(pResult);
}

#pragma mark -

bool create_folder(path_t *absolute_path){
    
    bool success = false;
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];
    [path release];
    [fm release];
#else
    success = SHCreateDirectory(NULL, (PCWSTR)absolute_path);
#endif
    
    return success;
}

void create_parent_folder(path_t *absolute_path){
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder((path_t *)folderPath.c_str());
    [filePath release];
#else
    wchar_t    fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(absolute_path, fDrive, fDir, fName, fExt);
    absolute_path_t folderPath = fDrive;
    folderPath += fDir;
    create_folder((path_t *)folderPath.c_str());
#endif
}

#pragma mark download

size_t curl_write_function_for_path(void *buffer,
                                    size_t size,
                                    size_t nmemb,
                                    path_ctx *ctx)
{
    size_t len = size * nmemb;
    
    if(ctx->useWildCard)
    {
        if(ctx->f)
        {
            fwrite(buffer, size, nmemb, ctx->f);
        }else
        {
            len = 0;
        }
    }else
    {
        create_parent_folder((path_t *)ctx->path);
        FILE *f = CPathOpen (ctx->path, ctx->shouldAppend ? CPathAppend : CPathCreate);
        ctx->shouldAppend = TRUE;
        
        if(f)
        {
            fwrite(buffer, size, nmemb, f);
            fclose(f);
        }else
        {
            len = 0;
        }
    }
    
    return len;
}

size_t curl_chunk_bgn_function(struct curl_fileinfo *finfo,
                               path_ctx *ctx,
                               int remains)
{
    absolute_path_t path = absolute_path_t(ctx->dir);
    
#if VERSIONMAC
    absolute_path_t filename = absolute_path_t(finfo->filename);
#else
    C_TEXT t;
    t.setUTF8String((const uint8_t *)finfo->filename, strlen(finfo->filename));
    absolute_path_t filename = (const wchar_t *)t.getUTF16StringPtr();
#endif
    
    if((finfo->filetype) == CURLFILETYPE_FILE)
    {
        ctx->path = path.append(filename).c_str();
        create_parent_folder((path_t *)ctx->path);
        ctx->f = CPathOpen (ctx->path, CPathCreate);
        if(!ctx->f)
        {
            return CURL_CHUNK_BGN_FUNC_FAIL;
        }
    }
    
    return CURL_CHUNK_BGN_FUNC_OK;
}

size_t curl_chunk_end_function(path_ctx *ctx)
{
    if(ctx->f)
    {
        fclose(ctx->f);
        ctx->f = NULL;
    }
    
    return CURL_CHUNK_END_FUNC_OK;
}

void cURL_FTP_Receive(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT Param3;
    C_TEXT Param4;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    curl_set_options(curl, Param1, userInfo, path);
    
    path_ctx ctx;
    ctx.f = NULL;
    ctx.useWildCard = FALSE;
    ctx.shouldAppend = FALSE;
    ctx.path = NULL;
    ctx.dir = NULL;
    
    CPathString local_path;
    
#if VERSIONMAC
    Param2.copyPath(&local_path);
    remove_trailing_separator(local_path);
    ctx.path = (const char *)local_path.c_str();
#else
    local_path = Param2.getUTF16StringPtr();
    remove_trailing_separator(local_path);
    ctx.path = (const wchar_t *)local_path.c_str();
#endif
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    if(Param3.getIntValue())
    {
        ctx.useWildCard =TRUE;
        curl_easy_setopt(curl, CURLOPT_WILDCARDMATCH, 1L);
        curl_easy_setopt(curl, CURLOPT_CHUNK_BGN_FUNCTION, curl_chunk_bgn_function);
        curl_easy_setopt(curl, CURLOPT_CHUNK_END_FUNCTION, curl_chunk_end_function);
        curl_easy_setopt(curl, CURLOPT_CHUNK_DATA, &ctx);
#if VERSIONMAC
        local_path += folder_separator;
        ctx.dir = (const char *)local_path.c_str();
#else
        local_path += folder_separator;
        ctx.dir = (const wchar_t *)local_path.c_str();
#endif
    }
    
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &ctx);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_path);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param4, userInfo));
    
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param4.toParamAtIndex(pParams, 4);
    
    returnValue.setReturn(pResult);
}

#pragma mark upload

size_t curl_read_function_for_path(void *buffer,
                                   size_t size,
                                   size_t nmemb,
                                   path_ctx *ctx)
{
    size_t len = size * nmemb;
    FILE *f;
    
    f = CPathOpen (ctx->path, CPathRead);
    
    if(f)
    {
        fseek(f, ctx->pos, SEEK_SET);
        len = fread(buffer, size, nmemb, f);
        ctx->pos += len;
        fclose(f);
    }else
    {
        len = 0;/* file not found */
    }
    
    return len;
}

void cURL_FTP_Send(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT Param3;
    C_TEXT Param4;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    curl_set_options(curl, Param1, userInfo, path);
    
    path_ctx ctx;
    ctx.pos = 0L;
    
    CPathString local_path;
#if VERSIONMAC
    Param2.copyPath(&local_path);
    ctx.path = (const char *)local_path.c_str();
#else
    local_path = Param2.getUTF16StringPtr();
    ctx.path = (const wchar_t *)local_path.c_str();
#endif
    
    /* file size */
    curl_off_t fileSize = 0L;
    FILE *f = CPathOpen (ctx.path, CPathRead);
    if(f)
    {
        fseek(f, 0L, SEEK_END);
        fileSize = (curl_off_t)ftell(f);
        fclose(f);
        
        if(fileSize != -1L)
        {
            curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, fileSize);
        }
        
        if(Param3.getIntValue())
        {
            curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, CURLFTP_CREATE_DIR_RETRY);
        }
        
        curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);
        
        curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
        curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
        
        curl_easy_setopt(curl, CURLOPT_READDATA, &ctx);
        curl_easy_setopt(curl, CURLOPT_READFUNCTION, curl_read_function_for_path);
        
        returnValue.setIntValue(curl_perform(mcurl, curl, Param4, userInfo));
    }
    
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param4.toParamAtIndex(pParams, 4);
    returnValue.setReturn(pResult);
}

#pragma mark -


#pragma mark dirlist

size_t curl_write_function_for_text(void *buffer,
                                    size_t size,
                                    size_t nmemb,
                                    CUTF8String& text)
{
    size_t len = size * nmemb;
    text.append((const uint8_t *)buffer, len);
    
    return len;
}

void cURL_FTP_GetDirList(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    curl_set_options(curl, Param1, userInfo, path);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    /* body */
    CUTF8String dirlist;
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &dirlist);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_text);
    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "LIST");
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param2.setUTF8String(&dirlist);
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    
    returnValue.setReturn(pResult);
}

void cURL_FTP_PrintDir(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    curl_set_options(curl, Param1, userInfo, path);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    /* body */
    CUTF8String dirlist;
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &dirlist);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_text);
    curl_easy_setopt(curl, CURLOPT_DIRLISTONLY, 1L);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param2.setUTF8String(&dirlist);
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    
    returnValue.setReturn(pResult);
}

#pragma mark fileinfo

size_t curl_header_function_for_fileinfo(void *buffer,
                                         size_t size,
                                         size_t nmemb,
                                         CUTF8String& fileSize)
{
    size_t len = size * nmemb;
    std::string line = std::string((const char *)buffer, len);
    
    /* Reply format is like (File status)
     213<space><size>
     */
    
    if(line.find("213 ") == 0)
    {
        size_t length = line.length() -4;
        for(size_t i = length + 3; i > 0; --i)
        {
            if(line.compare(i, 1, "\n") == 0)
            {
                length--;continue;
            }
            if(line.compare(i, 1, "\r") == 0)
            {
                length--;continue;
            }
            break;
        }
        
        fileSize = CUTF8String((const uint8_t *)line.substr(4).c_str(), length);
    }
    
    return len;
}

void cURL_FTP_GetFileInfo(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    curl_set_options(curl, Param1, userInfo, path);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    curl_easy_setopt(curl, CURLOPT_FILETIME, 1L);
    
    /* header */
    CUTF8String fileSize;
    curl_easy_setopt(curl, CURLOPT_HEADERDATA, &fileSize);
    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, curl_header_function_for_fileinfo);
    
    CURLcode result = curl_perform(mcurl, curl, Param3, userInfo);
    
    CUTF16String fileInfo;
    
    JSONNODE *info = json_new(JSON_NODE);
    
    if(result == CURLE_OK)
    {
        json_set_s_for_key(info, L"size", (const char *)fileSize.c_str());
        
        long _fileTime;
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &_fileTime))
        {
            char buf[80];
            time_t fileTime = (time_t)_fileTime;
            struct tm ts = *gmtime(&fileTime);
            strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%SZ", &ts);
            json_set_s_for_key(info, L"date", (const char *)buf);
        }
        json_stringify(info, fileInfo, FALSE);
        
        json_delete(info);
    }
    
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param2.setUTF16String(&fileInfo);
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    
    returnValue.setIntValue(result);
    returnValue.setReturn(pResult);
}

#pragma mark system

size_t curl_header_function_for_system(void *buffer,
                                       size_t size,
                                       size_t nmemb,
                                       CUTF8String& system)
{
    size_t len = size * nmemb;
    std::string line = std::string((const char *)buffer, len);
    
    /* Reply format is like
     215<space><OS-name><space><commentary>
     */
    
    if(line.find("215 ") == 0)
    {
        size_t length = line.length() -4;
        for(size_t i = length + 3; i > 0; --i)
        {
            if(line.compare(i, 1, "\n") == 0)
            {
                length--;continue;
            }
            if(line.compare(i, 1, "\r") == 0)
            {
                length--;continue;
            }
            break;
        }
        
        system = CUTF8String((const uint8_t *)line.substr(4).c_str(), length);
    }
    
    return len;
}

void cURL_FTP_System(sLONG_PTR *pResult, PackagePtr pParams)
{
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    
    curl_set_options(curl, Param1, userInfo, path);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    /* header */
    CUTF8String system;
    curl_easy_setopt(curl, CURLOPT_HEADERDATA, &system);
    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, curl_header_function_for_system);
    
    struct curl_slist *h = NULL;
    h = curl_slist_append(h, "SYST");
    
    curl_easy_setopt(curl, CURLOPT_PREQUOTE, h);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    Param2.setUTF8String(&system);
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    
    returnValue.setReturn(pResult);
}


#pragma mark JSON

void json_wconv(const wchar_t *value, CUTF16String *u16)
{
    size_t wlen = wcslen(value);
    
#if VERSIONWIN
    *u16 = CUTF16String((const PA_Unichar *)value, wlen);
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)value, wlen*sizeof(wchar_t), kCFStringEncodingUTF32LE, true);
    if(str)
    {
        int len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        *u16 = CUTF16String((const PA_Unichar *)&buf[0], len);
        CFRelease(str);
    }
#endif
}

void json_wconv(const wchar_t *value, CUTF8String *u8)
{
    C_TEXT t;
    size_t wlen = wcslen(value);
    
#if VERSIONWIN
    t.setUTF16String((const PA_Unichar *)value, wlen);
#else
    CUTF16String u16;
    json_wconv(value, &u16);
    t.setUTF16String(&u16);
#endif
    t.copyUTF8String(u8);
}

void json_wconv(const char *value, std::wstring &u32)
{
    if ((value) && strlen(value))
    {
        C_TEXT t;
        CUTF8String u8 = CUTF8String((const uint8_t *)value);
        
        t.setUTF8String(&u8);
        
#if VERSIONWIN
        u32 = std::wstring((wchar_t *)t.getUTF16StringPtr());
#else
        CFStringRef str = CFStringCreateWithCharacters(kCFAllocatorDefault, (const UniChar *)t.getUTF16StringPtr(), t.getUTF16Length());
        if(str)
        {
            size_t size = CFStringGetMaximumSizeForEncoding(CFStringGetLength(str), kCFStringEncodingUTF32LE) + sizeof(wchar_t);
            std::vector<uint8_t> buf(size);
            CFIndex len = 0;
            CFIndex count = CFStringGetBytes(str, CFRangeMake(0, CFStringGetLength(str)), kCFStringEncodingUTF32LE, 0, true, (UInt8 *)&buf[0], size, &len);
            u32 = std::wstring((wchar_t *)&buf[0], count);
            CFRelease(str);
        }
#endif
    }
    else
    {
        u32 = L"";
    }
    
}

void json_push_back_s(JSONNODE *n, const char *value)
{
    if (n)
    {
        if (value)
        {
            std::wstring w32;
            json_wconv(value, w32);
            
            JSONNODE *e = json_new(JSON_STRING);
            json_set_a(e, w32.c_str());
            json_push_back(n, e);
        }
        else
        {
            JSONNODE *e = json_new(JSON_STRING);
            json_nullify(e);
            json_push_back(n, e);
        }
    }
    
}

void json_set_s(JSONNODE *n, const char *value)
{
    if (n)
    {
        if (value)
        {
            std::wstring w32;
            json_wconv(value, w32);
            json_set_a(n, w32.c_str());
        }
        else
        {
            json_nullify(n);
        }
    }
}

void json_set_s_for_key(JSONNODE *n, json_char *key, const char *value)
{
    if (n)
    {
        if (value)
        {
            std::wstring w32;
            json_wconv(value, w32);
            
            JSONNODE *e = json_get(n, key);
            if (e)
            {
                json_set_a(e, w32.c_str());//over-write existing value
            }
            else
            {
                json_push_back(n, json_new_a(key, w32.c_str()));
            }
            
        }
        else
        {
            JSONNODE *e = json_get(n, key);
            if (e)
            {
                json_nullify(e);//over-write existing value
            }
            else
            {
                JSONNODE *node = json_new_a(key, L"");
                json_nullify(node);
                json_push_back(n, node);
            }
        }
    }
}

void json_set_b_for_key(JSONNODE *n, json_char *key, json_bool_t value)
{
    if (n)
    {
        JSONNODE *e = json_get(n, key);
        if (e)
        {
            json_set_b(e, value);//over-write existing value
        }
        else
        {
            json_push_back(n, json_new_b(key, value));
        }
    }
}

void json_set_i_for_key(JSONNODE *n, json_char *key, json_int_t value)
{
    if (n)
    {
        JSONNODE *e = json_get(n, key);
        if (e)
        {
            json_set_i(e, value);//over-write existing value
        }
        else
        {
            json_push_back(n, json_new_i(key, value));
        }
    }
}

void json_stringify(JSONNODE *json, CUTF16String &t, BOOL pretty)
{
    json_char *json_string = pretty ? json_write_formatted(json) : json_write(json);
    std::wstring wstr = std::wstring(json_string);
#if VERSIONWIN
    t = CUTF16String((const PA_Unichar *)wstr.c_str(), (uint32_t)wstr.length());
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)wstr.c_str(), wstr.size()*sizeof(wchar_t), kCFStringEncodingUTF32LE, true);
    if(str)
    {
        int len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        t = CUTF16String((const PA_Unichar *)&buf[0], len);
        CFRelease(str);
    }
#endif
    json_free(json_string);
}

#pragma mark JSON cURL

CURLoption json_get_curl_option_name(JSONNODE *n)
{
    CURLoption v = (CURLoption)0;
    
    if(n)
    {
        v = (CURLoption)json_as_int(n);
        
        json_char *name = json_name(n);
        
        if (name)
        {
            std::wstring s = std::wstring((const wchar_t *)name);
            if (s.compare(L"VERBOSE") == 0)
            {
                v = CURLOPT_VERBOSE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"USE_SSL") == 0)
            {
                v = CURLOPT_USE_SSL;goto json_get_curl_option_exit;
            }
            if (s.compare(L"URL") == 0)
            {
                v = CURLOPT_URL;goto json_get_curl_option_exit;
            }
            if (s.compare(L"USERNAME") == 0)
            {
                v = CURLOPT_USERNAME;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PASSWORD") == 0)
            {
                v = CURLOPT_PASSWORD;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTPPORT") == 0)
            {
                v = CURLOPT_FTPPORT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"APPEND") == 0)
            {
                v = CURLOPT_APPEND;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTP_ACCOUNT") == 0)
            {
                v = CURLOPT_FTP_ACCOUNT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"PRIVATE") == 0)
            {
                v = CURLOPT_PRIVATE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTP_USE_EPRT") == 0)
            {
                v = CURLOPT_FTP_USE_EPRT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTP_USE_EPSV") == 0)
            {
                v = CURLOPT_FTP_USE_EPSV;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTP_USE_PRET") == 0)
            {
                v = CURLOPT_FTP_USE_PRET;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTP_ALTERNATIVE_TO_USER") == 0)
            {
                v = CURLOPT_FTP_ALTERNATIVE_TO_USER;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTP_FILEMETHOD") == 0)
            {
                v = CURLOPT_FTP_FILEMETHOD;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TCP_KEEPALIVE") == 0)
            {
                v = CURLOPT_TCP_KEEPALIVE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TCP_KEEPIDLE") == 0)
            {
                v = CURLOPT_TCP_KEEPIDLE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TCP_KEEPINTVL") == 0)
            {
                v = CURLOPT_TCP_KEEPINTVL;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTP_RESPONSE_TIMEOUT") == 0)
            {
                v = CURLOPT_FTP_RESPONSE_TIMEOUT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"CONNECTTIMEOUT") == 0)
            {
                v = CURLOPT_CONNECTTIMEOUT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"TIMEOUT") == 0)
            {
                v = CURLOPT_TIMEOUT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"LOW_SPEED_TIME") == 0)
            {
                v = CURLOPT_LOW_SPEED_TIME;goto json_get_curl_option_exit;
            }
            if (s.compare(L"LOW_SPEED_LIMIT") == 0)
            {
                v = CURLOPT_LOW_SPEED_LIMIT;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSL_VERIFYHOST") == 0)
            {
                v = CURLOPT_SSL_VERIFYHOST;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSL_VERIFYPEER") == 0)
            {
                v = CURLOPT_SSL_VERIFYPEER;goto json_get_curl_option_exit;
            }
            if (s.compare(L"CAINFO") == 0)
            {
                v = CURLOPT_CAINFO;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTPSSLAUTH") == 0)
            {
                v = CURLOPT_FTPSSLAUTH;goto json_get_curl_option_exit;
            }
            if (s.compare(L"FTP_SSL_CCC") == 0)
            {
                v = CURLOPT_FTP_SSL_CCC;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSH_AUTH_TYPES") == 0)
            {
                v = CURLOPT_SSH_AUTH_TYPES;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSH_COMPRESSION") == 0)
            {
                v = CURLOPT_SSH_COMPRESSION;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSH_HOST_PUBLIC_KEY_MD5") == 0)
            {
                v = CURLOPT_SSH_HOST_PUBLIC_KEY_MD5;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSH_PUBLIC_KEYFILE") == 0)
            {
                v = CURLOPT_SSH_PUBLIC_KEYFILE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSH_PRIVATE_KEYFILE") == 0)
            {
                v = CURLOPT_SSH_PRIVATE_KEYFILE;goto json_get_curl_option_exit;
            }
            if (s.compare(L"SSH_KNOWNHOSTS") == 0)
            {
                v = CURLOPT_SSH_KNOWNHOSTS;goto json_get_curl_option_exit;
            }
            if (s.compare(L"UPKEEP_INTERVAL_MS") == 0)
            {
                v = CURLOPT_UPKEEP_INTERVAL_MS; goto json_get_curl_option_exit;
            }
            if (s.compare(L"DISALLOW_USERNAME_IN_URL") == 0)
            {
                v = CURLOPT_DISALLOW_USERNAME_IN_URL; goto json_get_curl_option_exit;
            }
            if (s.compare(L"PROXY_TLS13_CIPHERS") == 0)
            {
                v = CURLOPT_PROXY_TLS13_CIPHERS; goto json_get_curl_option_exit;
            }
            if (s.compare(L"TLS13_CIPHERS") == 0)
            {
                v = CURLOPT_TLS13_CIPHERS; goto json_get_curl_option_exit;
            }
            if (s.compare(L"DNS_SHUFFLE_ADDRESSES") == 0)
            {
                v = CURLOPT_DNS_SHUFFLE_ADDRESSES; goto json_get_curl_option_exit;
            }
            if (s.compare(L"HAPROXYPROTOCOL") == 0)
            {
                v = CURLOPT_HAPROXYPROTOCOL; goto json_get_curl_option_exit;
            }
            if (s.compare(L"DOH_URL") == 0)
            {
                v = CURLOPT_DOH_URL; goto json_get_curl_option_exit;
            }
            if (s.compare(L"UPLOAD_BUFFERSIZE") == 0)
            {
                v = CURLOPT_UPLOAD_BUFFERSIZE; goto json_get_curl_option_exit;
            }
            if (s.compare(L"HAPPY_EYEBALLS_TIMEOUT_MS") == 0)
            {
                v = CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS; goto json_get_curl_option_exit;
            }
            
        json_get_curl_option_exit:
            json_free(name);
        }
    }
    
    return v;
}

void json_get_curl_option_m(CURL *curl, CURLoption option, JSONNODE *n)
{
    if(n)
    {
        json_int_t v =  json_as_int(n);
        
        json_char *value = json_as_string(n);
        
        if(value)
        {
            std::wstring s = std::wstring((const wchar_t *)value);
            if (s.compare(L"PUBLICKEY") != std::string::npos)
            {
                v = v|CURLSSH_AUTH_PUBLICKEY;
            }
            if (s.compare(L"PASSWORD") != std::string::npos)
            {
                v = v|CURLSSH_AUTH_PASSWORD;
            }
            if (s.compare(L"HOST") != std::string::npos)
            {
                v = v|CURLSSH_AUTH_HOST;
            }
            if (s.compare(L"KEYBOARD") != std::string::npos)
            {
                v = v|CURLSSH_AUTH_KEYBOARD;
            }
            if (s.compare(L"AGENT") != std::string::npos)
            {
                v = v|CURLSSH_AUTH_AGENT;
            }
            
            json_free(value);
        }
        
        
        curl_easy_setopt(curl, option, value);
    }
}

void json_get_curl_option_c(CURL *curl, CURLoption option, JSONNODE *n)
{
    if(n)
    {
        json_int_t value = json_get_curl_option_value(n);
        curl_easy_setopt(curl, option, value);
    }
}

void json_get_curl_option_i(CURL *curl, CURLoption option, JSONNODE *n)
{
    if(n)
    {
        json_int_t value = json_as_int(n);
        curl_easy_setopt(curl, option, value);
    }
}

void json_get_curl_option_p(CURL *curl, CURLoption option, JSONNODE *n)
{
    if(n)
    {
        json_char *value = json_as_string(n);
        
        if(value)
        {
            CUTF8String u;
            json_wconv(value, &u);
#if VERSIONMAC
            /* hfs to posix */
            C_TEXT t;
            t.setUTF8String(&u);
            t.copyPath(&u);
#endif
            curl_easy_setopt(curl, option, u.c_str());
            json_free(value);
        }
    }
}

void json_get_curl_option_s(CURL *curl, CURLoption option, JSONNODE *n, CUTF8String& path, BOOL removeFileName)
{
    if(n)
    {
        json_char *value = json_as_string(n);
        
        if(value)
        {
            CUTF8String u, u2;
            json_wconv(value, &u);
            u2 = u;
            
//            curl_easy_setopt(curl, option, u.c_str());
            if(option == CURLOPT_URL)
            {
                size_t pos = u.find((const uint8_t *)"://");
                if(pos != std::string::npos)
                {
                    /* skip protocol */
                    u2 = u.substr(pos + 4);
                }
                pos = u2.find((const uint8_t *)"/");
                if(pos != std::string::npos)
                {
                    /* path: skip host */
                    path = u2.substr(pos + 1);
                }
                if(removeFileName)
                {
                   std::size_t pos = u.find_last_of((const uint8_t *)"/");
                    if((pos < u.length()) && (pos != std::string::npos))
                    {
                        u = u.substr(0, pos + 1);
                    }
                }
            }/* CURLOPT_URL */
            
            curl_easy_setopt(curl, option, u.c_str());

            json_free(value);
        }
    }
}

long json_get_curl_option_value(JSONNODE *n)
{
    long v = json_as_int(n);
    
    json_char *value = json_as_string(n);
    
    if(value)
    {
        std::wstring s = std::wstring((const wchar_t *)value);
        if (s.compare(L"MULTICWD") == 0)
        {
            v = CURLFTPMETHOD_MULTICWD;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"NOCWD") == 0)
        {
            v = CURLFTPMETHOD_NOCWD;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"SINGLECWD") == 0)
        {
            v = CURLFTPMETHOD_SINGLECWD;goto json_get_curl_option_value_exit;
        }
        
        if (s.compare(L"AUTH_DEFAULT") == 0)
        {
            v = CURLFTPAUTH_DEFAULT;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"AUTH_SSL") == 0)
        {
            v = CURLFTPAUTH_SSL;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"AUTH_TLS") == 0)
        {
            v = CURLFTPAUTH_TLS;goto json_get_curl_option_value_exit;
        }
        
        if (s.compare(L"CCC_NONE") == 0)
        {
            v = CURLFTPSSL_CCC_NONE;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"CCC_PASSIVE") == 0)
        {
            v = CURLFTPSSL_CCC_PASSIVE;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"CCC_ACTIVE") == 0)
        {
            v = CURLFTPSSL_CCC_ACTIVE;goto json_get_curl_option_value_exit;
        }
        
        if (s.compare(L"USESSL_NONE") == 0)
        {
            v = CURLUSESSL_NONE;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"USESSL_TRY") == 0)
        {
            v = CURLUSESSL_TRY;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"USESSL_CONTROL") == 0)
        {
            v = CURLUSESSL_CONTROL;goto json_get_curl_option_value_exit;
        }
        if (s.compare(L"USESSL_ALL") == 0)
        {
            v = CURLUSESSL_ALL;goto json_get_curl_option_value_exit;
        }
        
    json_get_curl_option_value_exit:
        json_free(value);
    }
    
    return v;
}

#pragma mark -

protocol_type_t curl_set_options(CURL *curl, C_TEXT& Param1, C_TEXT& userInfo, CUTF8String& path, BOOL removeFileName)
{
    protocol_type_t protocol = PROTOCOL_TYPE_UNKNOWN;
    
    CUTF8String Param1_u8;
    Param1.copyUTF8String(&Param1_u8);
    std::wstring Param1_option;
    json_wconv((const char *)Param1_u8.c_str(), Param1_option);
    
    std::lock_guard<std::mutex> lock(mutexJson);
    
    JSONNODE *option = json_parse(Param1_option.c_str());
    if(option)
    {
        if (json_type(option) == JSON_NODE)
        {
            JSONNODE_ITERATOR i = json_begin(option);

            while (i != json_end(option))
            {
                CURLoption curl_option = json_get_curl_option_name(*i);
                switch (curl_option)
                {
                    case CURLOPT_PRIVATE:
                    {
                        json_char *value = json_as_string(*i);
                        if(value)
                        {
                            CUTF8String u;
                            json_wconv(value, &u);
                            userInfo.setUTF8String(&u);
                            json_free(value);
                        }
                    }
                        break;
                        
                        /* char */
                    case CURLOPT_USERNAME:
                    case CURLOPT_PASSWORD:
                    case CURLOPT_URL:
                    case CURLOPT_FTPPORT:
                    case CURLOPT_FTP_ACCOUNT:
                    case CURLOPT_FTP_ALTERNATIVE_TO_USER:
                    case CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
                    case CURLOPT_PROXY_TLS13_CIPHERS:
                    case CURLOPT_TLS13_CIPHERS:
                    case CURLOPT_DOH_URL:
                        json_get_curl_option_s(curl, curl_option, *i, path, removeFileName);
                        if(curl_option == CURLOPT_URL)
                        {
                            json_char *value = json_as_string(*i);
                            if(value)
                            {
                                CUTF8String u;
                                json_wconv(value, &u);
                                if(0 == u.find((const uint8_t *)"sftp:"))
                                {
                                    protocol = PROTOCOL_TYPE_SFTP;
                                }
                                
                                if(0 == u.find((const uint8_t *)"ftps:"))
                                {
                                    protocol = PROTOCOL_TYPE_FTPS;
                                }
                                json_free(value);
                            }
                        }
                        break;
                        
                        /* path */
                    case CURLOPT_CAINFO:
                    case CURLOPT_SSH_PUBLIC_KEYFILE:
                    case CURLOPT_SSH_PRIVATE_KEYFILE:
                    case CURLOPT_SSH_KNOWNHOSTS:
                        json_get_curl_option_p(curl, curl_option, *i);
                        break;
                        
                        /* long */
                    case CURLOPT_VERBOSE:
                    case CURLOPT_APPEND:
                    case CURLOPT_FTP_USE_EPRT:
                    case CURLOPT_FTP_USE_EPSV:
                    case CURLOPT_FTP_USE_PRET:
                    case CURLOPT_TCP_KEEPALIVE:
                    case CURLOPT_TCP_KEEPIDLE:
                    case CURLOPT_TCP_KEEPINTVL:
                    case CURLOPT_FTP_RESPONSE_TIMEOUT:
                    case CURLOPT_CONNECTTIMEOUT:
                    case CURLOPT_TIMEOUT:
                    case CURLOPT_LOW_SPEED_TIME:
                    case CURLOPT_LOW_SPEED_LIMIT:
                    case CURLOPT_SSL_VERIFYHOST:
                    case CURLOPT_SSL_VERIFYPEER:
                    case CURLOPT_SSH_COMPRESSION:
                    case CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS:
                    case CURLOPT_HAPROXYPROTOCOL:
                    case CURLOPT_UPLOAD_BUFFERSIZE:
                    case CURLOPT_UPKEEP_INTERVAL_MS:
                    case CURLOPT_DISALLOW_USERNAME_IN_URL:
                    case CURLOPT_DNS_SHUFFLE_ADDRESSES:
                        json_get_curl_option_i(curl, curl_option, *i);
                        break;
                        
                        /* constant or long */
                    case CURLOPT_FTP_FILEMETHOD:
                    case CURLOPT_FTPSSLAUTH:
                    case CURLOPT_FTP_SSL_CCC:
                    case CURLOPT_USE_SSL:
                        json_get_curl_option_c(curl, curl_option, *i);
                        break;
                        
                        /* constant bit mask or long */
                    case CURLOPT_SSH_AUTH_TYPES:
                        json_get_curl_option_m(curl, curl_option, *i);
                        break;
                        
                    default:
                        break;
                }
                
                ++i;
            }
            
        }
        json_delete(option);
    }
    
    return protocol;
}

void curl_get_info(CURL *curl, CUTF16String& json)
{
    long responseCode, connectCode, fileTime, redirectCount, headerSize, requestSize, lastSocket;
    long sslVerifyResult, localPort, primaryPort, numConnects, osErrNo, httpAuthAvail, proxyAuthAvail;
    double totalTime, nameLookupTime, connectTime, appConnectTime, preTransferTime, startTransferTime, redirectTime;
    double sizeUpload, speedUpload, sizeDownload, speedDownload, contentLengthDownload, contentLengthUpload;
    long rtspClientCseq, rtspServerCseq, rtspCseqRecv, conditionUnmet;
    char *effectiveUrl = NULL;
    char *redirectUrl = NULL;
    char *contentType = NULL;
    char *ftpEntryPath = NULL;
    char *localIp = NULL;
    char *primaryIp = NULL;
    char *rtspSessionId = NULL;
    
    std::lock_guard<std::mutex> lock(mutexJson);
    
    JSONNODE *info = json_new(JSON_NODE);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &conditionUnmet))
        json_set_i_for_key(info, L"conditionUnmet", conditionUnmet);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_UPLOAD, &contentLengthUpload))
        json_set_i_for_key(info, L"contentLengthUpload", contentLengthUpload);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CLIENT_CSEQ, &rtspClientCseq))
        json_set_i_for_key(info, L"rtspClientCseq", rtspClientCseq);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SERVER_CSEQ, &rtspServerCseq))
        json_set_i_for_key(info, L"rtspServerCseq", rtspServerCseq);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CSEQ_RECV, &rtspCseqRecv))
        json_set_i_for_key(info, L"rtspCseqRecv", rtspCseqRecv);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LASTSOCKET, &lastSocket))
        json_set_i_for_key(info, L"lastSocket", lastSocket);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT, &primaryPort))
        json_set_i_for_key(info, L"primaryPort", primaryPort);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &localPort))
        json_set_i_for_key(info, L"localPort", localPort);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &contentLengthDownload))
        json_set_i_for_key(info, L"contentLengthDownload", contentLengthDownload);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE, &connectCode))
        json_set_i_for_key(info, L"connectCode", connectCode);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &fileTime))
        json_set_i_for_key(info, L"fileTime", fileTime);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &totalTime))
        json_set_i_for_key(info, L"totalTime", totalTime);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE , &requestSize))
        json_set_i_for_key(info, L"requestSize", requestSize);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &headerSize))
        json_set_i_for_key(info, L"headerSize", headerSize);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &speedUpload))
        json_set_i_for_key(info, L"speedUpload", speedUpload);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD, &speedDownload))
        json_set_i_for_key(info, L"speedDownload", speedDownload);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &sizeDownload))
        json_set_i_for_key(info, L"sizeDownload", sizeDownload);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &sizeUpload))
        json_set_i_for_key(info, L"sizeUpload", sizeUpload);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTPAUTH_AVAIL, &httpAuthAvail))
        json_set_i_for_key(info, L"httpAuthAvail", httpAuthAvail);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROXYAUTH_AVAIL, &proxyAuthAvail))
        json_set_i_for_key(info, L"proxyAuthAvail", proxyAuthAvail);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_OS_ERRNO, &osErrNo))
        json_set_i_for_key(info, L"osErrNo", osErrNo);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &numConnects))
        json_set_i_for_key(info, L"numConnects", numConnects);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &responseCode))
        json_set_i_for_key(info, L"responseCode", responseCode);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME, &nameLookupTime))
        json_set_i_for_key(info, L"nameLookupTime", nameLookupTime);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &connectTime))
        json_set_i_for_key(info, L"connectTime", connectTime);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME, &appConnectTime))
        json_set_i_for_key(info, L"appConnectTime", appConnectTime);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME, &preTransferTime))
        json_set_i_for_key(info, L"preTransferTime", preTransferTime);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME, &startTransferTime))
        json_set_i_for_key(info, L"startTransferTime", startTransferTime);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME, &redirectTime))
        json_set_i_for_key(info, L"redirectTime", redirectTime);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT , &sslVerifyResult))
        json_set_i_for_key(info, L"sslVerifyResult", sslVerifyResult);
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &redirectCount))
        json_set_i_for_key(info, L"redirectCount", redirectCount);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &effectiveUrl)))
        json_set_s_for_key(info, L"effectiveUrl", effectiveUrl);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_IP, &localIp)))
        json_set_s_for_key(info, L"localIp", localIp);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &contentType)))
        json_set_s_for_key(info, L"contentType", contentType);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &primaryIp)))
        json_set_s_for_key(info, L"primaryIp", primaryIp);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &redirectUrl)))
        json_set_s_for_key(info, L"redirectUrl", redirectUrl);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &ftpEntryPath)))
        json_set_s_for_key(info, L"ftpEntryPath", ftpEntryPath);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SESSION_ID, &rtspSessionId)))
        json_set_s_for_key(info, L"rtspSessionId", rtspSessionId);
    
    json_stringify(info, json, FALSE);
    
    json_delete(info);
}

void last_path_component(CUTF8String& path)
{
    size_t pos = path.length() -1;
    size_t end = pos;
    size_t len = pos - 1;
    
    for(size_t i = pos; i > 0; --i)
    {
        if((path.compare(i, 1, (const uint8_t *)"/") == 0) && (i == end))
        {
            pos--;len--;continue;
        }
        if(path.compare(i, 1, (const uint8_t *)"/") != 0)
        {
            pos--;continue;
        }
        len++;break;
    }
    
    path = path.substr(pos + 1, len - pos);
}

void remove_trailing_separator(CUTF8String& path)
{
    size_t pos = path.length() -1;
    
    if((path.compare(pos, 1, (const uint8_t *)"/") == 0))
    {
        path = path.substr(0, pos);
    }
    
}

void remove_trailing_separator(CUTF16String& path)
{
    size_t pos = path.length() -1;
    
    if((path.compare(pos, 1, (const PA_Unichar *)L"\\") == 0))
    {
        path = path.substr(0, pos);
    }
    
}

void curl_unescape_path(CURL *curl, CUTF8String& path)
{
    int ftp_path_len = 0;
    char *ftp_path = curl_easy_unescape(curl, (const char *)path.c_str(), path.length(), &ftp_path_len);
    path = CUTF8String((const uint8_t *)ftp_path, ftp_path_len);
    curl_free(ftp_path);
}
