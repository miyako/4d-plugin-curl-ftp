/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-cURL-FTP.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : cURL FTP
 #	author : miyako
 #	2019/09/12
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-cURL-FTP.h"

#pragma mark -

std::mutex mutexMcurl;

CURLM *gmcurl = NULL;

void OnStartup()
{
    curl_global_init(CURL_GLOBAL_DEFAULT);
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        gmcurl = curl_multi_init();
    }
}

void OnExit()
{
    if(gmcurl)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        curl_multi_cleanup(gmcurl);
        gmcurl = NULL;
    }
    
    curl_global_cleanup();
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kDeinitPlugin :
                OnExit();
                break;
                
			// --- cURL FTP
            
			case 1 :
				cURL_FTP_Delete(params);
				break;
			case 2 :
				cURL_FTP_GetDirList(params);
				break;
			case 3 :
				cURL_FTP_GetFileInfo(params);
				break;
			case 4 :
				cURL_FTP_MakeDir(params);
				break;
			case 5 :
				cURL_FTP_PrintDir(params);
				break;
			case 6 :
				cURL_FTP_Receive(params);
				break;
			case 7 :
				cURL_FTP_RemoveDir(params);
				break;
			case 8 :
				cURL_FTP_Rename(params);
				break;
			case 9 :
				cURL_FTP_Send(params);
				break;
			case 10 :
				cURL_FTP_System(params);
				break;

        }

	}
	catch(...)
	{

	}
}

#pragma mark -

void cURL_FTP_Delete(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;
    
    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
    
    CUTF8String fullpath = path;
    
    protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path, ie, oe, TRUE);
    
    apply_input_encoding(ie, path);
    curl_unescape_path(curl, path);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    struct curl_slist *h = NULL;
    
    //    last_path_component(path);/* already done by curl_set_options(,,,,,TRUE) */
    
    CUTF8String quote;
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            quote = CUTF8String((const uint8_t *)"rm \"/")
            .append(fullpath)
            .append((const uint8_t *)"\"");/* rm takes an absolute path */
            break;
            
        default:
            quote = CUTF8String((const uint8_t *)"DELE ")
            .append(path);/* DELE takes a relative path;quote are not allowed */
            break;
    }
    
    h = curl_slist_append(h, (const char *)quote.c_str());
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            curl_easy_setopt(curl, CURLOPT_QUOTE, h);
            break;
            
        default:
            curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
            break;
    }
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param2, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    
    Param2.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);
}

void cURL_FTP_GetDirList(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;
    
    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
    
    curl_set_options(curl, Param1, userInfo, path, ie, oe);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    /* body */
    CUTF8String dirlist;
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &dirlist);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_text);
    curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "LIST");
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    
    curl_easy_cleanup(curl);
    
    apply_output_encoding(dirlist, oe);
    
    Param2.setUTF8String(&dirlist);
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    
    returnValue.setReturn(pResult);
}

void cURL_FTP_GetFileInfo(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;
    
    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
    
    /* protocol_type_t protocol = */ curl_set_options(curl, Param1, userInfo, path, ie, oe);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    curl_easy_setopt(curl, CURLOPT_FILETIME, 1L);
    
    /* header */
    //    CUTF8String fileSize;
    //    curl_easy_setopt(curl, CURLOPT_HEADERDATA, &fileSize);
    //    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, curl_header_function_for_fileinfo);
    
    CURLcode result = curl_perform(mcurl, curl, Param3, userInfo);
    
    CUTF16String fileInfo;
    
    Json::Value info;
    
    if(result == CURLE_OK)
    {
        curl_off_t fileSize = 0;
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD_T, &fileSize))
        {
            
        }

        info["size"] = (Json::LargestInt)fileSize;
        
        long _fileTime;
        if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &_fileTime))
        {
            char buf[80];
            time_t fileTime = (time_t)_fileTime;
            struct tm ts = *gmtime(&fileTime);
            strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%SZ", &ts);
            
            info["date"] = (const char *)buf;
        }
        
        Json::StreamWriterBuilder builder;
        std::string options = Json::writeString(builder, info);
        convertFromString(options, fileInfo);

    }
    
    curl_easy_cleanup(curl);
    
    Param2.setUTF16String(&fileInfo);
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    
    returnValue.setIntValue(result);
    returnValue.setReturn(pResult);
}

void cURL_FTP_MakeDir(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_LONGINT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;
    
    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
    
    protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path, ie, oe);
    
    apply_input_encoding(ie, path);
    
    curl_unescape_path(curl, path);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    struct curl_slist *h = NULL;
    
    if(Param2.getIntValue())
    {
        curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, CURLFTP_CREATE_DIR_RETRY);
    }
    
    CUTF8String quote;
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            quote = CUTF8String((const uint8_t *)"mkdir \"/")
            .append(path)
            .append((const uint8_t *)"\"");
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
            
        default:
            quote = CUTF8String((const uint8_t *)"MKD ").append(path);
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
    }
    
    curl_easy_setopt(curl, CURLOPT_QUOTE, h);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    
    Param3.toParamAtIndex(pParams, 3);
    returnValue.setReturn(pResult);
}

void cURL_FTP_PrintDir(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;
    
    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
    
    curl_set_options(curl, Param1, userInfo, path, ie, oe);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    /* body */
    CUTF8String dirlist;
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &dirlist);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_text);
    curl_easy_setopt(curl, CURLOPT_DIRLISTONLY, 1L);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    curl_easy_cleanup(curl);
    //    curl_multi_cleanup(mcurl);
    
    apply_output_encoding(dirlist, oe);
    
    Param2.setUTF8String(&dirlist);
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    
    returnValue.setReturn(pResult);
}

void cURL_FTP_Receive(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT Param3;
    C_TEXT Param4;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;
    
    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
    
    curl_set_options(curl, Param1, userInfo, path, ie, oe);
    
    path_ctx ctx;
    ctx.f = NULL;
    ctx.useWildCard = FALSE;
    ctx.shouldAppend = FALSE;
//    ctx.path = NULL;
//    ctx.dir = NULL;
    
    CPathString local_path;
    
#if VERSIONMAC
    Param2.copyPath(&local_path);
    remove_trailing_separator(local_path);
//    ctx.path = (const char *)local_path.c_str();
#else
    local_path = Param2.getUTF16StringPtr();
    remove_trailing_separator(local_path);
//    ctx.path = (const wchar_t *)local_path.c_str();
#endif
    
    memset(ctx.path, 0x00, MAX_LENGTH_FOR_PATH * sizeof(path_t));
    memcpy(ctx.path, local_path.c_str(), local_path.length() * sizeof(path_t));
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    if(Param3.getIntValue())
    {
        ctx.useWildCard =TRUE;
        curl_easy_setopt(curl, CURLOPT_WILDCARDMATCH, 1L);
        curl_easy_setopt(curl, CURLOPT_CHUNK_BGN_FUNCTION, curl_chunk_bgn_function);
        curl_easy_setopt(curl, CURLOPT_CHUNK_END_FUNCTION, curl_chunk_end_function);
        curl_easy_setopt(curl, CURLOPT_CHUNK_DATA, &ctx);
#if VERSIONMAC
        local_path += folder_separator;
//        ctx.dir = (const char *)local_path.c_str();
#else
        local_path += folder_separator;
//        ctx.dir = (const wchar_t *)local_path.c_str();
#endif
        
        memset(ctx.dir, 0x00, MAX_LENGTH_FOR_PATH * sizeof(path_t));
        memcpy(ctx.dir, local_path.c_str(), local_path.length() * sizeof(path_t));
    }
    
    curl_easy_setopt(curl, CURLOPT_WRITEDATA, &ctx);
    curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_path);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param4, userInfo));
    
    curl_easy_cleanup(curl);
    
    Param4.toParamAtIndex(pParams, 4);
    
    returnValue.setReturn(pResult);
    
}

void cURL_FTP_RemoveDir(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;
    
    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
    
    CUTF8String fullpath = path;
    
    protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path, ie, oe, TRUE);
    
    apply_input_encoding(ie, path);
    curl_unescape_path(curl, path);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    struct curl_slist *h = NULL;
    
    //    last_path_component(path);/* already done by curl_set_options(,,,,,TRUE) */
    
    CUTF8String quote;
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            quote = CUTF8String((const uint8_t *)"rmdir \"/")
            .append(fullpath)
            .append((const uint8_t *)"\"");
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
            
        default:
            quote = CUTF8String((const uint8_t *)"RMD ").append(path);
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
    }
    
    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param2, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    
    Param2.toParamAtIndex(pParams, 2);
    returnValue.setReturn(pResult);
}

void cURL_FTP_Rename(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;
    
    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
    
    protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path, ie, oe);
    
    apply_input_encoding(ie, path);
    
    curl_unescape_path(curl, path);
    
    CUTF8String fullpath = path;
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    struct curl_slist *h = NULL;
    
    last_path_component(path);
    
    remove_trailing_separator(path);
    
    CUTF8String name;
    Param2.copyUTF8String(&name);
    
    apply_input_encoding(ie, name);
    
    CUTF8String quote;
    
    switch (protocol) {
        case PROTOCOL_TYPE_SFTP:
            quote = CUTF8String((const uint8_t *)"rename \"/")
            .append(fullpath)
            .append((const uint8_t *)"\" ")
            .append((const uint8_t *)"\"/")
            .append(name)
            .append((const uint8_t *)"\"");
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
            
        default:
            quote = CUTF8String((const uint8_t *)"RNFR ").append(path);
            h = curl_slist_append(h, (const char *)quote.c_str());
            
            quote = CUTF8String((const uint8_t *)"RNTO ").append(name);
            h = curl_slist_append(h, (const char *)quote.c_str());
            break;
    }
    
    curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    
    Param3.toParamAtIndex(pParams, 3);
    returnValue.setReturn(pResult);
}

void cURL_FTP_Send(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_LONGINT Param3;
    C_TEXT Param4;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    Param4.fromParamAtIndex(pParams, 4);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;

    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
        
    curl_set_options(curl, Param1, userInfo, path, ie, oe);
    
    path_ctx ctx;
    ctx.pos = 0L;
    
    CPathString local_path;
#if VERSIONMAC
    Param2.copyPath(&local_path);
//    ctx.path = (const char *)local_path.c_str();
#else
    local_path = Param2.getUTF16StringPtr();
//    ctx.path = (const wchar_t *)local_path.c_str();
#endif
    
    memset(ctx.path, 0x00, MAX_LENGTH_FOR_PATH * sizeof(path_t));
    memcpy(ctx.path, local_path.c_str(), local_path.length() * sizeof(path_t));
    
    /* file size */
    curl_off_t fileSize = 0L;
    FILE *f = CPathOpen (ctx.path, CPathRead);
    if(f)
    {
        fseek(f, 0L, SEEK_END);
        fileSize = (curl_off_t)ftell(f);
        fclose(f);
        
        if(fileSize != -1L)
        {
            curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, fileSize);
        }
        
        if(Param3.getIntValue())
        {
            curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, CURLFTP_CREATE_DIR_RETRY);
        }
        
        curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);
        
        curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
        curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
        curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
        
        curl_easy_setopt(curl, CURLOPT_READDATA, &ctx);
        curl_easy_setopt(curl, CURLOPT_READFUNCTION, curl_read_function_for_path);
        
        returnValue.setIntValue(curl_perform(mcurl, curl, Param4, userInfo));
    }
    
    curl_easy_cleanup(curl);
    
    Param4.toParamAtIndex(pParams, 4);
    returnValue.setReturn(pResult);
}

void cURL_FTP_System(PA_PluginParameters params) {

    sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
    PackagePtr pParams = (PackagePtr)params->fParameters;
    
    C_TEXT Param1;
    C_TEXT Param2;
    C_TEXT Param3;
    C_LONGINT returnValue;
    
    Param1.fromParamAtIndex(pParams, 1);
    Param2.fromParamAtIndex(pParams, 2);
    Param3.fromParamAtIndex(pParams, 3);
    
    CURL *curl = curl_easy_init();
    CURLM *mcurl = gmcurl;//curl_multi_init();
    
    C_TEXT userInfo; /* PRIVATE */
    CUTF8String path;
    CUTF8String ie;
    CUTF8String oe;
    
    http_debug_ctx debug_ctx;

    curl_set_debug(curl, Param1, &debug_ctx);
    
    curl_set_options(curl, Param1, userInfo, path, ie, oe);
    
    curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
    curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
    curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
    
    /* header */
    CUTF8String system;
    curl_easy_setopt(curl, CURLOPT_HEADERDATA, &system);
    curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, curl_header_function_for_system);
    
    struct curl_slist *h = NULL;
    h = curl_slist_append(h, "SYST");
    
    curl_easy_setopt(curl, CURLOPT_PREQUOTE, h);
    
    returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
    
    curl_slist_free_all(h);
    
    curl_easy_cleanup(curl);
    
    apply_output_encoding(system, oe);
    
    Param2.setUTF8String(&system);
    Param2.toParamAtIndex(pParams, 2);
    Param3.toParamAtIndex(pParams, 3);
    
    returnValue.setReturn(pResult);
}

#pragma mark debug

void curl_set_debug(CURL *curl, C_TEXT& Param1, http_debug_ctx *debug_ctx) {
    
    debug_ctx->size_CURLINFO_TEXT = 0L;
    debug_ctx->size_CURLINFO_HEADER_IN = 0L;
    debug_ctx->size_CURLINFO_HEADER_OUT = 0L;
    debug_ctx->size_CURLINFO_DATA_IN = 0L;
    debug_ctx->size_CURLINFO_DATA_OUT = 0L;
    debug_ctx->size_CURLINFO_SSL_DATA_IN = 0L;
    debug_ctx->size_CURLINFO_SSL_DATA_OUT = 0L;
    
    CPathString debug_folder_path;

    if(curl_set_debug_option(curl,
                             Param1 /* options */,
                             debug_folder_path))
    {
        if(debug_folder_path.length() < MAX_LENGTH_FOR_PATH) {
            memset(debug_ctx->path, 0x00, MAX_LENGTH_FOR_PATH * sizeof(path_t));
            memcpy(debug_ctx->path, debug_folder_path.c_str(), debug_folder_path.length() * sizeof(path_t));
            curl_easy_setopt(curl, CURLOPT_DEBUGDATA, debug_ctx);
            curl_easy_setopt(curl, CURLOPT_DEBUGFUNCTION, curl_debug_function);
            curl_easy_setopt(curl, CURLOPT_VERBOSE, 1);
        }
    }
}

BOOL curl_set_debug_option(CURL *curl,
                           C_TEXT& Param1,
                           CPathString& debug_folder_path) {
    
    BOOL isDebugEnabled = FALSE;
    CUTF8String Param1_u8;
    Param1.copyUTF8String(&Param1_u8);

    Json::Value root;
    Json::CharReaderBuilder builder;
    std::string errors;
    
    Json::CharReader *reader = builder.newCharReader();
    bool parse = reader->parse((const char *)Param1_u8.c_str(),
                               (const char *)Param1_u8.c_str() + Param1_u8.size(),
                               &root,
                               &errors);
    delete reader;
    
    if(parse)
    {
        if(root.isObject())
        {
            for(Json::Value::const_iterator it = root.begin() ; it != root.end() ; it++)
            {
                Json::Value key = it.key();
                JSONCPP_STRING name = it.name();
                
                if(name == "DEBUG")
                {
                    if(it->isString())
                    {
                        std::string path;
                        path = it->asString();
                        
                        if(path.length())
                        {
                            C_TEXT t;
                            t.setUTF8String((const uint8_t *)path.c_str(), path.length());
#if VERSIONMAC
                            CUTF8String _path;
                            t.copyPath(&_path);
                            debug_folder_path = (const uint8_t *)_path.c_str();
                            if(debug_folder_path.at(debug_folder_path.size() - 1) != '/') debug_folder_path += '/';
#else
                            CUTF16String _path;
                            t.copyUTF16String(&_path);
                            debug_folder_path = (const PA_Unichar *)_path.c_str();
                            if(debug_folder_path.at(debug_folder_path.size() - 1) != L'\\') debug_folder_path += L'\\';
#endif
                            
//                            create_folder((path_t *)debug_folder_path.c_str());
                            isDebugEnabled = TRUE;
                        }
                    }
                    break;
                }
            }
        }
    }

    return isDebugEnabled;
}

#pragma mark iconv

size_t apply_input_encoding(generic_string_t& src, generic_string_t& ie) {
    
    size_t iconv_value = 0;
    
    if(ie.length() != 0) {
        
        //convert
        const char *inEncoding = "utf-8";
        const char *outEncoding = (const char *)ie.c_str();
        
        iconv_t conv = iconv_open(outEncoding, inEncoding);
        
        if (conv != (iconv_t)(-1)) {
            
            char *inData = (char *)src.c_str();
            size_t inDataLen = (size_t)src.length();
            size_t outDataLen = (size_t)(inDataLen * 4) + 4;
            size_t outDataSize = outDataLen;
            
            char *outData = (char *)calloc(outDataLen, 1);
            char *outDataPtr = outData;
            
            size_t iconv_value;
            
            iconv_value = iconv (conv, &inData, &inDataLen, &outData, &outDataLen);
            
            if (iconv_value)
            {
                /* errno */
            }else{
                src = generic_string_t((const uint8_t *)outDataPtr, outDataSize-outDataLen);
            }
            free(outDataPtr);
            
            iconv_close(conv);
        }
    }
    
    return iconv_value;
}

size_t apply_output_encoding(generic_string_t& src, generic_string_t& oe) {
    
    size_t iconv_value = 0;
    
    if(oe.length() != 0) {
        
        //convert
        const char *inEncoding = (const char *)oe.c_str();
        const char *outEncoding = "utf-8";
        
        iconv_t conv = iconv_open(outEncoding, inEncoding);
        
        if (conv != (iconv_t)(-1)) {
            
            char *inData = (char *)src.c_str();
            size_t inDataLen = (size_t)src.length();
            size_t outDataLen = (size_t)(inDataLen * 4) + 4;
            size_t outDataSize = outDataLen;
            
            char *outData = (char *)calloc(outDataLen, 1);
            char *outDataPtr = outData;
            
            size_t iconv_value;
            
            iconv_value = iconv (conv, &inData, &inDataLen, &outData, &outDataLen);
            
            if (iconv_value)
            {
                /* errno */
            }else{
                src = generic_string_t((const uint8_t *)outDataPtr, outDataSize-outDataLen);
            }
            free(outDataPtr);
            
            iconv_close(conv);
        }
    }
    
    return iconv_value;
}

#pragma mark path

void curl_unescape_path(CURL *curl, CUTF8String& path) {
    
    int ftp_path_len = 0;
    char *ftp_path = curl_easy_unescape(curl,
                                        (const char *)path.c_str(),
                                        (int)path.length(),
                                        &ftp_path_len);
    path = CUTF8String((const uint8_t *)ftp_path, ftp_path_len);
    curl_free(ftp_path);
}

void remove_trailing_separator(CUTF16String& path) {
    
    size_t pos = path.length() -1;
    
    if((path.compare(pos, 1, (const PA_Unichar *)L"\\") == 0))
    {
        path = path.substr(0, pos);
    }
    
}

void remove_trailing_separator(CUTF8String& path) {
    
    size_t pos = path.length() -1;
    
    if((path.compare(pos, 1, (const uint8_t *)"/") == 0))
    {
        path = path.substr(0, pos);
    }
    
}

void last_path_component(CUTF8String& path) {
    
    size_t pos = path.length() -1;
    size_t end = pos;
    size_t len = pos - 1;
    
    for(size_t i = pos; i > 0; --i)
    {
        if((path.compare(i, 1, (const uint8_t *)"/") == 0) && (i == end))
        {
            pos--;len--;continue;
        }
        if(path.compare(i, 1, (const uint8_t *)"/") != 0)
        {
            pos--;continue;
        }
        len++;break;
    }
    
    path = path.substr(pos + 1, len - pos);
}

#pragma mark info

void curl_get_info(CURL *curl, CUTF16String& json) {
    
    long responseCode,
    connectCode,
    fileTime,
    redirectCount,
    headerSize,
    requestSize,
    lastSocket,
    sslVerifyResult,
    localPort,
    primaryPort,
    numConnects,
    osErrNo,
    httpAuthAvail,
    proxyAuthAvail,
    rtspClientCseq,
    rtspServerCseq,
    rtspCseqRecv,
    conditionUnmet;
    
    double totalTime,
    nameLookupTime,
    connectTime,
    appConnectTime,
    preTransferTime,
    startTransferTime,
    redirectTime;
        
    char *effectiveUrl = NULL;
    char *redirectUrl = NULL;
    char *contentType = NULL;
    char *ftpEntryPath = NULL;
    char *localIp = NULL;
    char *primaryIp = NULL;
    char *rtspSessionId = NULL;
    
    curl_off_t speedUploadT,
    speedDownloadT,
    sizeUploadT,
    sizeDownloadT,
    contentLengthDownloadT,
    contentLengthUploadT;
    
#define JSONCPP_STRING_VALUE(s) s ? s : ""
    
    Json::Value info;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &conditionUnmet))
        info["conditionUnmet"] = (Json::Int64)conditionUnmet;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_UPLOAD_T, &contentLengthUploadT))
        info["contentLengthUpload"] = (Json::Int64)contentLengthUploadT;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD_T, &contentLengthDownloadT))
        info["contentLengthDownload"] = (Json::Int64)contentLengthDownloadT;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD_T, &speedUploadT))
        info["speedUpload"] = (Json::UInt64)speedUploadT;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD_T, &speedDownloadT))
        info["speedDownload"] = (Json::UInt64)speedDownloadT;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD_T, &sizeDownloadT))
        info["sizeDownload"] = (Json::UInt64)sizeDownloadT;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD_T, &sizeUploadT))
        info["sizeUpload"] = (Json::UInt64)sizeUploadT;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CLIENT_CSEQ, &rtspClientCseq))
        info["rtspClientCseq"] = (Json::Int64)rtspClientCseq;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SERVER_CSEQ, &rtspServerCseq))
        info["rtspServerCseq"] = (Json::Int64)rtspServerCseq;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CSEQ_RECV, &rtspCseqRecv))
        info["rtspCseqRecv"] = (Json::Int64)rtspCseqRecv;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LASTSOCKET, &lastSocket))
        info["lastSocket"] = (Json::Int64)lastSocket;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT, &primaryPort))
        info["primaryPort"] = (Json::Int64)primaryPort;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &localPort))
        info["localPort"] = (Json::Int64)localPort;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE, &connectCode))
        info["connectCode"] = (Json::Int64)connectCode;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &fileTime))
        info["fileTime"] = (Json::Int64)fileTime;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE , &requestSize))
        info["requestSize"] = (Json::Int64)requestSize;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &headerSize))
        info["headerSize"] = (Json::Int64)headerSize;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTPAUTH_AVAIL, &httpAuthAvail))
        info["httpAuthAvail"] = (Json::Int64)httpAuthAvail;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROXYAUTH_AVAIL, &proxyAuthAvail))
        info["proxyAuthAvail"] = (Json::Int64)proxyAuthAvail;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_OS_ERRNO, &osErrNo))
        info["osErrNo"] = (Json::Int64)osErrNo;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &numConnects))
        info["numConnects"] = (Json::Int64)numConnects;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &responseCode))
        info["responseCode"] = (Json::Int64)responseCode;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT , &sslVerifyResult))
        info["sslVerifyResult"] = (Json::Int64)sslVerifyResult;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &redirectCount))
        info["redirectCount"] = (Json::Int64)redirectCount;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &totalTime))
        info["totalTime"] = totalTime;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME, &nameLookupTime))
        info["nameLookupTime"] = nameLookupTime;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &connectTime))
        info["connectTime"] = connectTime;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME, &appConnectTime))
        info["appConnectTime"] = appConnectTime;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME, &preTransferTime))
        info["preTransferTime"] = preTransferTime;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME, &startTransferTime))
        info["startTransferTime"] = startTransferTime;
    
    if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME, &redirectTime))
        info["redirectTime"] = redirectTime;
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &effectiveUrl)))
        info["effectiveUrl"] = JSONCPP_STRING_VALUE(effectiveUrl);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_IP, &localIp)))
        info["localIp"] = JSONCPP_STRING_VALUE(localIp);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &contentType)))
        info["contentType"] = JSONCPP_STRING_VALUE(contentType);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &primaryIp)))
        info["primaryIp"] = JSONCPP_STRING_VALUE(primaryIp);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &redirectUrl)))
        info["redirectUrl"] = JSONCPP_STRING_VALUE(redirectUrl);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &ftpEntryPath)))
        info["ftpEntryPath"] = JSONCPP_STRING_VALUE(ftpEntryPath);
    
    if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SESSION_ID, &rtspSessionId)))
        info["rtspSessionId"] = JSONCPP_STRING_VALUE(rtspSessionId);
    
    Json::StreamWriterBuilder builder;
    std::string options = Json::writeString(builder, info);
    convertFromString(options, json);
    
    /*
     Json::StyledWriter writer;
     std::string options = writer.write(info);
     convertFromString(options, json);
     */

}

void convertFromString(std::string &fromString, CUTF16String &toString) {
    
#ifdef _WIN32
    int len = MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), NULL, 0);
    
    if(len){
        std::vector<uint8_t> buf((len + 1) * sizeof(PA_Unichar));
        if(MultiByteToWideChar(CP_UTF8, 0, (LPCSTR)fromString.c_str(), fromString.length(), (LPWSTR)&buf[0], len)){
            toString = CUTF16String((const PA_Unichar *)&buf[0]);
        }
    }else{
        toString = CUTF16String((const PA_Unichar *)L"\0\0");
    }
#else
    CFStringRef str = CFStringCreateWithBytes(kCFAllocatorDefault, (const UInt8 *)fromString.c_str(), fromString.length(), kCFStringEncodingUTF8, true);
    if(str){
        CFIndex len = CFStringGetLength(str);
        std::vector<uint8_t> buf((len+1) * sizeof(PA_Unichar));
        CFStringGetCharacters(str, CFRangeMake(0, len), (UniChar *)&buf[0]);
        toString = CUTF16String((const PA_Unichar *)&buf[0]);
        CFRelease(str);
    }
#endif
}

#pragma mark options

protocol_type_t curl_set_options(CURL *curl,
                                 C_TEXT& Param1,
                                 C_TEXT& userInfo,
                                 CUTF8String& path,
                                 CUTF8String& ie,
                                 CUTF8String& oe,
                                 BOOL removeFileName) {
    
    protocol_type_t protocol = PROTOCOL_TYPE_UNKNOWN;
    
    CUTF8String Param1_u8;
    Param1.copyUTF8String(&Param1_u8);
    
    Json::Value root;
    Json::CharReaderBuilder builder;
    std::string errors;
    
    Json::CharReader *reader = builder.newCharReader();
    bool parse = reader->parse((const char *)Param1_u8.c_str(),
                               (const char *)Param1_u8.c_str() + Param1_u8.size(),
                               &root,
                               &errors);
    delete reader;
    
    if(parse)
    {
        if(root.isObject())
        {
            for(Json::Value::const_iterator it = root.begin() ; it != root.end() ; it++)
            {
                Json::Value key = it.key();
                JSONCPP_STRING name = it.name();
                
                CURLoption curl_option = json_get_curl_option_name(it);
                
                switch (curl_option)
                {
                    case CURLOPT_PRIVATE:
                        if(it->isString())
                        {
                            JSONCPP_STRING value = it->asString();
                            userInfo.setUTF8String((const uint8_t *)value.c_str(), (uint32_t)value.length());
                        }
                        break;
                        
                    case CURLOPT_ENCODING_IN:
                        if(it->isString())
                        {
                            JSONCPP_STRING value = it->asString();
                            ie = CUTF8String((const uint8_t *)value.c_str(), value.length());
                        }
                        break;
                        
                    case CURLOPT_ENCODING_OUT:
                        if(it->isString())
                        {
                            JSONCPP_STRING value = it->asString();
                            oe = CUTF8String((const uint8_t *)value.c_str(), value.length());
                        }
                        break;
                        
                        /* string */
                    case CURLOPT_PROXY:
                    case CURLOPT_USERPWD:
                    case CURLOPT_PROXYUSERPWD:
                    case CURLOPT_RANGE:
                    case CURLOPT_REFERER:
                    case CURLOPT_FTPPORT:
                    case CURLOPT_USERAGENT:
                    case CURLOPT_COOKIE:
                    case CURLOPT_KEYPASSWD:
                    case CURLOPT_CUSTOMREQUEST:
                    case CURLOPT_INTERFACE:
                    case CURLOPT_KRBLEVEL:
                    case CURLOPT_RANDOM_FILE:
                    case CURLOPT_EGDSOCKET:
                    case CURLOPT_SSL_CIPHER_LIST:
                    case CURLOPT_SSLCERTTYPE:
                    case CURLOPT_SSLKEYTYPE:
                    case CURLOPT_ACCEPT_ENCODING:
                    case CURLOPT_FTP_ACCOUNT:
                    case CURLOPT_COOKIELIST:
                    case CURLOPT_FTP_ALTERNATIVE_TO_USER:
                    case CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
                    case CURLOPT_USERNAME:
                    case CURLOPT_PASSWORD:
                    case CURLOPT_PROXYUSERNAME:
                    case CURLOPT_PROXYPASSWORD:
                    case CURLOPT_NOPROXY:
                    case CURLOPT_SSH_KNOWNHOSTS:
                    case CURLOPT_RTSP_SESSION_ID:
                    case CURLOPT_RTSP_STREAM_URI:
                    case CURLOPT_RTSP_TRANSPORT:
                    case CURLOPT_TLSAUTH_USERNAME:
                    case CURLOPT_TLSAUTH_PASSWORD:
                    case CURLOPT_TLSAUTH_TYPE:
                    case CURLOPT_DNS_SERVERS:
                    case CURLOPT_MAIL_AUTH:
                    case CURLOPT_XOAUTH2_BEARER:
                    case CURLOPT_DNS_INTERFACE:
                    case CURLOPT_DNS_LOCAL_IP4:
                    case CURLOPT_DNS_LOCAL_IP6:
                    case CURLOPT_LOGIN_OPTIONS:
                    case CURLOPT_PROXY_SERVICE_NAME:
                    case CURLOPT_SERVICE_NAME:
                    case CURLOPT_DEFAULT_PROTOCOL:
                    case CURLOPT_PROXY_TLSAUTH_USERNAME:
                    case CURLOPT_PROXY_TLSAUTH_PASSWORD:
                    case CURLOPT_PROXY_TLSAUTH_TYPE:
                    case CURLOPT_PROXY_SSLCERTTYPE:
                    case CURLOPT_PROXY_SSLKEYTYPE:
                    case CURLOPT_PROXY_KEYPASSWD:
                    case CURLOPT_PROXY_SSL_CIPHER_LIST:
                    case CURLOPT_PRE_PROXY:
                    case CURLOPT_PROXY_PINNEDPUBLICKEY:
                    case CURLOPT_REQUEST_TARGET:
                    case CURLOPT_TLS13_CIPHERS:
                    case CURLOPT_PROXY_TLS13_CIPHERS:
                    case CURLOPT_DOH_URL:
                    case CURLOPT_MAIL_FROM:
                    case CURLOPT_URL:
                        if(it->isString())
                        {
                            JSONCPP_STRING value = it->asString();
                            JSONCPP_STRING url, url_without_protocol;
                            
                            if(curl_option == CURLOPT_URL)
                            {
                                size_t pos = value.find((const char *)"://");
                                if(pos != std::string::npos)
                                {
                                    /* skip protocol */
                                    url = value;
                                    url_without_protocol = value.substr(pos + strlen("://"));
                                }
                                pos = url_without_protocol.find((const char *)"/");
                                if(pos != std::string::npos)
                                {
                                    /* path: skip host */
                                    path = CUTF8String((const uint8_t *)url_without_protocol.substr(pos + 1).c_str());
                                }
                                if(removeFileName)
                                {
                                    /* remove last path component */
                                    std::size_t pos = value.find_last_of((const char *)"/");
                                    if((pos < value.length()) && (pos != std::string::npos))
                                    {
                                        value = value.substr(0, pos + 1);
                                    }
                                }
                                
                                if(0 == value.find((const char *)"sftp:"))
                                {
                                    protocol = PROTOCOL_TYPE_SFTP;
                                }
                                
                                if(0 == value.find((const char *)"ftps:"))
                                {
                                    protocol = PROTOCOL_TYPE_FTPS;
                                }
                                
                                if(0 == value.find((const char *)"ftp:"))
                                {
                                    protocol = PROTOCOL_TYPE_FTP;
                                }
                            }
                            curl_easy_setopt(curl, curl_option, value.c_str());
                        }
                        break;
                        /* path */
                    case CURLOPT_SSLCERT:
                    case CURLOPT_COOKIEFILE:
                    case CURLOPT_CAINFO:
                    case CURLOPT_COOKIEJAR:
                    case CURLOPT_SSLKEY:
                    case CURLOPT_CAPATH:
                    case CURLOPT_NETRC_FILE:
                    case CURLOPT_SSH_PUBLIC_KEYFILE:
                    case CURLOPT_SSH_PRIVATE_KEYFILE:
                    case CURLOPT_CRLFILE:
                    case CURLOPT_ISSUERCERT:
                    case CURLOPT_PROXY_CAINFO:
                    case CURLOPT_PROXY_CAPATH:
                    case CURLOPT_PROXY_SSLCERT:
                    case CURLOPT_PROXY_SSLKEY:
                    case CURLOPT_PROXY_CRLFILE:
                        if(it->isString())
                        {
                            JSONCPP_STRING value = it->asString();
#if VERSIONMAC
                            /* hfs to posix */
                            C_TEXT t;
                            t.setUTF8String((const uint8_t *)value.c_str(), (uint32_t)value.length());
                            CUTF8String u;
                            t.copyPath(&u);
                            curl_easy_setopt(curl, curl_option, (const char *)u.c_str());
#else
                            curl_easy_setopt(curl, curl_option, value.c_str());
#endif
                        }
                        break;
                        
                        /* path or value */
                    case CURLOPT_PINNEDPUBLICKEY:
                        if(it->isString())
                        {
                            JSONCPP_STRING value = it->asString();
                            if (value.find_first_of("sha256//") == std::string::npos)
                            {
#if VERSIONMAC
                                /* hfs to posix */
                                C_TEXT t;
                                t.setUTF8String((const uint8_t *)value.c_str(), (uint32_t)value.length());
                                CUTF8String u;
                                t.copyPath(&u);
                                curl_easy_setopt(curl, curl_option, (const char *)u.c_str());
#else
                                curl_easy_setopt(curl, curl_option, value.c_str());
#endif
                            }else
                            {
                                curl_easy_setopt(curl, curl_option, value.c_str());
                            }
                        }
                        break;
                        /* longint */
                    case CURLOPT_PORT:
                    case CURLOPT_TIMEOUT:
                    case CURLOPT_LOW_SPEED_LIMIT:
                    case CURLOPT_LOW_SPEED_TIME:
                    case CURLOPT_RESUME_FROM:
                    case CURLOPT_CRLF:
                    case CURLOPT_TIMEVALUE:
                    case CURLOPT_HEADER:
                    case CURLOPT_NOBODY:
                    case CURLOPT_FAILONERROR:
                    case CURLOPT_UPLOAD:
                    case CURLOPT_POST:
                    case CURLOPT_DIRLISTONLY:
                    case CURLOPT_APPEND:
                    case CURLOPT_NETRC:
                    case CURLOPT_FOLLOWLOCATION:
                    case CURLOPT_PUT:
                    case CURLOPT_AUTOREFERER:
                    case CURLOPT_PROXYPORT:
                    case CURLOPT_HTTPPROXYTUNNEL:
                    case CURLOPT_SSL_VERIFYPEER:
                    case CURLOPT_MAXREDIRS:
                    case CURLOPT_FILETIME:
                    case CURLOPT_MAXCONNECTS:
                    case CURLOPT_FRESH_CONNECT:
                    case CURLOPT_FORBID_REUSE:
                    case CURLOPT_CONNECTTIMEOUT:
                    case CURLOPT_HTTPGET:
                    case CURLOPT_SSL_VERIFYHOST:
                    case CURLOPT_FTP_USE_EPSV:
                    case CURLOPT_DNS_CACHE_TIMEOUT:
                    case CURLOPT_COOKIESESSION:
                    case CURLOPT_BUFFERSIZE:
                    case CURLOPT_UNRESTRICTED_AUTH:
                    case CURLOPT_FTP_USE_EPRT:
                    case CURLOPT_HTTPAUTH:
                    case CURLOPT_FTP_CREATE_MISSING_DIRS:
                    case CURLOPT_PROXYAUTH:
                    case CURLOPT_FTP_RESPONSE_TIMEOUT:
                    case CURLOPT_IPRESOLVE:
                    case CURLOPT_MAXFILESIZE:
                    case CURLOPT_IGNORE_CONTENT_LENGTH:
                    case CURLOPT_FTP_SKIP_PASV_IP:
                    case CURLOPT_FTP_FILEMETHOD:
                    case CURLOPT_LOCALPORT:
                    case CURLOPT_LOCALPORTRANGE:
                    case CURLOPT_CONNECT_ONLY:
                    case CURLOPT_SSL_SESSIONID_CACHE:
                    case CURLOPT_SSH_AUTH_TYPES:
                    case CURLOPT_FTP_SSL_CCC:
                    case CURLOPT_TIMEOUT_MS:
                    case CURLOPT_CONNECTTIMEOUT_MS:
                    case CURLOPT_HTTP_TRANSFER_DECODING:
                    case CURLOPT_HTTP_CONTENT_DECODING:
                    case CURLOPT_NEW_FILE_PERMS:
                    case CURLOPT_NEW_DIRECTORY_PERMS:
                    case CURLOPT_POSTREDIR:
                    case CURLOPT_PROXY_TRANSFER_MODE:
                    case CURLOPT_ADDRESS_SCOPE:
                    case CURLOPT_CERTINFO:
                    case CURLOPT_TFTP_BLKSIZE:
                    case CURLOPT_PROTOCOLS:
                    case CURLOPT_REDIR_PROTOCOLS:
                    case CURLOPT_FTP_USE_PRET:
                    case CURLOPT_RTSP_REQUEST:
                    case CURLOPT_RTSP_CLIENT_CSEQ:
                    case CURLOPT_RTSP_SERVER_CSEQ:
                    case CURLOPT_WILDCARDMATCH:
                    case CURLOPT_TRANSFER_ENCODING:
                    case CURLOPT_ACCEPTTIMEOUT_MS:
                    case CURLOPT_TCP_KEEPALIVE:
                    case CURLOPT_TCP_KEEPIDLE:
                    case CURLOPT_TCP_KEEPINTVL:
                    case CURLOPT_SASL_IR:
                    case CURLOPT_SSL_ENABLE_NPN:
                    case CURLOPT_SSL_ENABLE_ALPN:
                    case CURLOPT_EXPECT_100_TIMEOUT_MS:
                    case CURLOPT_SSL_VERIFYSTATUS:
                    case CURLOPT_SSL_FALSESTART:
                    case CURLOPT_PATH_AS_IS:
                    case CURLOPT_PIPEWAIT:
                    case CURLOPT_STREAM_WEIGHT:
                    case CURLOPT_TFTP_NO_OPTIONS:
                    case CURLOPT_TCP_FASTOPEN:
                    case CURLOPT_KEEP_SENDING_ON_ERROR:
                    case CURLOPT_PROXY_SSL_VERIFYPEER:
                    case CURLOPT_PROXY_SSL_VERIFYHOST:
                    case CURLOPT_PROXY_SSL_OPTIONS:
                    case CURLOPT_SUPPRESS_CONNECT_HEADERS:
                    case CURLOPT_SOCKS5_AUTH:
                    case CURLOPT_SSH_COMPRESSION:
                    case CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS:
                    case CURLOPT_HAPROXYPROTOCOL:
                    case CURLOPT_DNS_SHUFFLE_ADDRESSES:
                    case CURLOPT_DISALLOW_USERNAME_IN_URL:
                    case CURLOPT_UPLOAD_BUFFERSIZE:
                    case CURLOPT_UPKEEP_INTERVAL_MS:
                        if(it->isNumeric())
                        {
                            curl_easy_setopt(curl, curl_option, it->asInt());
                        }else if(it->isString())
                        {
                            curl_easy_setopt(curl, curl_option, atoi(it->asString().c_str()));
                        }
                        break;
                        /* constant or long */
                    case CURLOPT_USE_SSL:
                    case CURLOPT_SSLVERSION:
                    case CURLOPT_HTTP_VERSION:
                    case CURLOPT_PROXY_SSLVERSION:
                    case CURLOPT_TIMECONDITION:
                    case CURLOPT_PROXYTYPE:
                    case CURLOPT_FTPSSLAUTH:
                    case CURLOPT_HEADEROPT:
                    {
                        curl_easy_setopt(curl, curl_option, json_get_curl_option_value(it));
                    }
                        break;
                        
                        /* array string */
                    case CURLOPT_CONNECT_TO:

                        break;
                    case CURLOPT_PROXYHEADER:

                        break;
                    case CURLOPT_HTTPHEADER:

                        break;
                    case CURLOPT_HTTP200ALIASES:

                        break;
                    case CURLOPT_RESOLVE:

                        break;
                    case CURLOPT_MAIL_RCPT:

                        break;
                    case CURLOPT_PREQUOTE:

                        break;
                    case CURLOPT_POSTQUOTE:

                        break;
                    case CURLOPT_QUOTE:

                        break;
                    case CURLOPT_TELNETOPTIONS:

                        break;
                    default:
                        break;
                }
            }
        }
    }

    return protocol;
}

long json_get_curl_option_value(Json::Value::const_iterator n) {
    
    long v = 0;
    
    if(n->isString()) {
    
            JSONCPP_STRING s = n->asString();
            
            if(s.length())
            {

        #define CHECK_CURLOPT_VALUE(__a,__b) if(s==__a){v=(CURLoption)__b;goto json_get_curl_option_value_exit;}
                
                    /* USE_SSL */
                    CHECK_CURLOPT_VALUE("USESSL_NONE",CURLUSESSL_NONE)
                    CHECK_CURLOPT_VALUE("USESSL_TRY",CURLUSESSL_TRY)
                    CHECK_CURLOPT_VALUE("USESSL_CONTROL",CURLUSESSL_CONTROL)
                    CHECK_CURLOPT_VALUE("USESSL_ALL",CURLUSESSL_ALL)
                    
                    /* SSLVERSION, PROXY_SSLVERSION */
                    CHECK_CURLOPT_VALUE("SSLVERSION_DEFAULT",CURL_SSLVERSION_DEFAULT)
                    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1",CURL_SSLVERSION_TLSv1)
                    CHECK_CURLOPT_VALUE("SSLVERSION_SSLv2",CURL_SSLVERSION_SSLv2)
                    CHECK_CURLOPT_VALUE("SSLVERSION_SSLv3",CURL_SSLVERSION_SSLv3)
                    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1_0",CURL_SSLVERSION_TLSv1_0)
                    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1_1",CURL_SSLVERSION_TLSv1_1)
                    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1_2",CURL_SSLVERSION_TLSv1_2)
                    CHECK_CURLOPT_VALUE("SSLVERSION_TLSv1_3",CURL_SSLVERSION_TLSv1_3)
                    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_DEFAULT",CURL_SSLVERSION_MAX_DEFAULT)
                    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_TLSv1_0",CURL_SSLVERSION_MAX_TLSv1_0)
                    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_TLSv1_1",CURL_SSLVERSION_MAX_TLSv1_1)
                    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_TLSv1_2",CURL_SSLVERSION_MAX_TLSv1_2)
                    CHECK_CURLOPT_VALUE("SSLVERSION_MAX_TLSv1_3",CURL_SSLVERSION_MAX_TLSv1_3)
                    
                    /* HEADEROPT */
                    CHECK_CURLOPT_VALUE("HEADER_UNIFIED",CURLHEADER_UNIFIED)
                    CHECK_CURLOPT_VALUE("HEADER_SEPARATE",CURLHEADER_SEPARATE)
                    
                    /* HTTP_VERSION */
                    CHECK_CURLOPT_VALUE("HTTP_VERSION_NONE",CURL_HTTP_VERSION_NONE)
                    CHECK_CURLOPT_VALUE("HTTP_VERSION_1_0",CURL_HTTP_VERSION_1_0)
                    CHECK_CURLOPT_VALUE("HTTP_VERSION_1_1",CURL_HTTP_VERSION_1_1)
                    CHECK_CURLOPT_VALUE("HTTP_VERSION_2",CURL_HTTP_VERSION_2)
                    CHECK_CURLOPT_VALUE("HTTP_VERSION_2TLS",CURL_HTTP_VERSION_2TLS)
                    CHECK_CURLOPT_VALUE("HTTP_VERSION_2_PRIOR_KNOWLEDGE",CURL_HTTP_VERSION_2_PRIOR_KNOWLEDGE)
                    
                    /* TIMECONDITION */
                    CHECK_CURLOPT_VALUE("TIMECOND_IFMODSINCE",CURL_TIMECOND_IFMODSINCE)
                    CHECK_CURLOPT_VALUE("TIMECOND_IFUNMODSINCE",CURL_TIMECOND_IFUNMODSINCE)
                    CHECK_CURLOPT_VALUE("TIMECOND_LASTMOD",CURL_TIMECOND_LASTMOD)
                    
                    /* PROXYTYPE */
                    CHECK_CURLOPT_VALUE("PROXY_HTTPS",CURLPROXY_HTTPS)
                    CHECK_CURLOPT_VALUE("PROXY_SOCKS4",CURLPROXY_SOCKS4)
                    CHECK_CURLOPT_VALUE("PROXY_SOCKS4A",CURLPROXY_SOCKS4A)
                    CHECK_CURLOPT_VALUE("PROXY_SOCKS5",CURLPROXY_SOCKS5)
                    
                    /* FTPSSLAUTH */
                    CHECK_CURLOPT_VALUE("FTPAUTH_SSL",CURLFTPAUTH_SSL)
                    CHECK_CURLOPT_VALUE("FTPAUTH_TLS",CURLFTPAUTH_TLS)
                    
                    /* compatibility */
                    CHECK_CURLOPT_VALUE("MULTICWD",CURLFTPMETHOD_MULTICWD)
                    CHECK_CURLOPT_VALUE("NOCWD",CURLFTPMETHOD_NOCWD)
                    CHECK_CURLOPT_VALUE("SINGLECWD",CURLFTPMETHOD_SINGLECWD)
                    CHECK_CURLOPT_VALUE("AUTH_DEFAULT",CURLFTPAUTH_DEFAULT)
                    CHECK_CURLOPT_VALUE("AUTH_SSL",CURLFTPAUTH_SSL)
                    CHECK_CURLOPT_VALUE("AUTH_TLS",CURLFTPAUTH_TLS)
                    CHECK_CURLOPT_VALUE("CCC_NONE",CURLFTPSSL_CCC_NONE)
                    CHECK_CURLOPT_VALUE("CCC_PASSIVE",CURLFTPSSL_CCC_PASSIVE)
                    CHECK_CURLOPT_VALUE("CCC_ACTIVE",CURLFTPSSL_CCC_ACTIVE)
                    CHECK_CURLOPT_VALUE("USESSL_NONE",CURLUSESSL_NONE)
                    CHECK_CURLOPT_VALUE("USESSL_TRY",CURLUSESSL_TRY)
                    CHECK_CURLOPT_VALUE("USESSL_CONTROL",CURLUSESSL_CONTROL)
                    CHECK_CURLOPT_VALUE("USESSL_ALL",CURLUSESSL_ALL)
                    
                json_get_curl_option_value_exit:

                    (void)0;

                }
        
    }else if(n->isNumeric()) {
        v = n->asInt();
    }
        
    return v;
}

CURLoption json_get_curl_option_name(Json::Value::const_iterator n) {
    
    CURLoption v = (CURLoption)0;
    
    JSONCPP_STRING s = n.name();

        if (s.length())
        {
            
#define CHECK_CURLOPT(__a,__b) if(s==__a){v=(CURLoption)__b;goto json_get_curl_option_exit;}
            
                /* special string */
                CHECK_CURLOPT("URL",CURLOPT_URL)
                CHECK_CURLOPT("READDATA",CURLOPT_READDATA)
                CHECK_CURLOPT("WRITEDATA",CURLOPT_WRITEDATA)
                CHECK_CURLOPT("AUTOPROXY",CURLOPT_AUTOPROXY)
                CHECK_CURLOPT("PRIVATE",CURLOPT_PRIVATE)
                CHECK_CURLOPT("ATOMIC",CURLOPT_ATOMIC)
                
                /* string */
                CHECK_CURLOPT("PROXY",CURLOPT_PROXY)
                CHECK_CURLOPT("USERPWD",CURLOPT_USERPWD)
                CHECK_CURLOPT("PROXYUSERPWD",CURLOPT_PROXYUSERPWD)
                CHECK_CURLOPT("RANGE",CURLOPT_RANGE)
                CHECK_CURLOPT("REFERER",CURLOPT_REFERER)
                CHECK_CURLOPT("FTPPORT",CURLOPT_FTPPORT)
                CHECK_CURLOPT("USERAGENT",CURLOPT_USERAGENT)
                CHECK_CURLOPT("COOKIE",CURLOPT_COOKIE)
                CHECK_CURLOPT("KEYPASSWD",CURLOPT_KEYPASSWD)
                CHECK_CURLOPT("CUSTOMREQUEST",CURLOPT_CUSTOMREQUEST)
                CHECK_CURLOPT("INTERFACE",CURLOPT_INTERFACE)
                CHECK_CURLOPT("KRBLEVEL",CURLOPT_KRBLEVEL)
                CHECK_CURLOPT("RANDOM_FILE",CURLOPT_RANDOM_FILE)
                CHECK_CURLOPT("EGDSOCKET",CURLOPT_EGDSOCKET)
                CHECK_CURLOPT("SSL_CIPHER_LIST",CURLOPT_SSL_CIPHER_LIST)
                CHECK_CURLOPT("SSLCERTTYPE",CURLOPT_SSLCERTTYPE)
                CHECK_CURLOPT("SSLKEYTYPE",CURLOPT_SSLKEYTYPE)
                CHECK_CURLOPT("ACCEPT_ENCODING",CURLOPT_ACCEPT_ENCODING)
                CHECK_CURLOPT("FTP_ACCOUNT",CURLOPT_FTP_ACCOUNT)
                CHECK_CURLOPT("COOKIELIST",CURLOPT_COOKIELIST)
                CHECK_CURLOPT("FTP_ALTERNATIVE_TO_USER",CURLOPT_FTP_ALTERNATIVE_TO_USER)
                CHECK_CURLOPT("SSH_HOST_PUBLIC_KEY_MD5",CURLOPT_SSH_HOST_PUBLIC_KEY_MD5)
                CHECK_CURLOPT("USERNAME",CURLOPT_USERNAME)
                CHECK_CURLOPT("PASSWORD",CURLOPT_PASSWORD)
                CHECK_CURLOPT("PROXYUSERNAME",CURLOPT_PROXYUSERNAME)
                CHECK_CURLOPT("PROXYPASSWORD",CURLOPT_PROXYPASSWORD)
                CHECK_CURLOPT("NOPROXY",CURLOPT_NOPROXY)
                CHECK_CURLOPT("SSH_KNOWNHOSTS",CURLOPT_SSH_KNOWNHOSTS)
                CHECK_CURLOPT("RTSP_SESSION_ID",CURLOPT_RTSP_SESSION_ID)
                CHECK_CURLOPT("RTSP_STREAM_URI",CURLOPT_RTSP_STREAM_URI)
                CHECK_CURLOPT("RTSP_TRANSPORT",CURLOPT_RTSP_TRANSPORT)
                CHECK_CURLOPT("TLSAUTH_USERNAME",CURLOPT_TLSAUTH_USERNAME)
                CHECK_CURLOPT("TLSAUTH_PASSWORD",CURLOPT_TLSAUTH_PASSWORD)
                CHECK_CURLOPT("TLSAUTH_TYPE",CURLOPT_TLSAUTH_TYPE)
                CHECK_CURLOPT("DNS_SERVERS",CURLOPT_DNS_SERVERS)
                CHECK_CURLOPT("MAIL_AUTH",CURLOPT_MAIL_AUTH)
                CHECK_CURLOPT("XOAUTH2_BEARER",CURLOPT_XOAUTH2_BEARER)
                CHECK_CURLOPT("DNS_INTERFACE",CURLOPT_DNS_INTERFACE)
                CHECK_CURLOPT("DNS_LOCAL_IP4",CURLOPT_DNS_LOCAL_IP4)
                CHECK_CURLOPT("DNS_LOCAL_IP6",CURLOPT_DNS_LOCAL_IP6)
                CHECK_CURLOPT("LOGIN_OPTIONS",CURLOPT_LOGIN_OPTIONS)
                CHECK_CURLOPT("PROXY_SERVICE_NAME",CURLOPT_PROXY_SERVICE_NAME)
                CHECK_CURLOPT("SERVICE_NAME",CURLOPT_SERVICE_NAME)
                CHECK_CURLOPT("DEFAULT_PROTOCOL",CURLOPT_DEFAULT_PROTOCOL)
                CHECK_CURLOPT("PROXY_TLSAUTH_USERNAME",CURLOPT_PROXY_TLSAUTH_USERNAME)
                CHECK_CURLOPT("PROXY_TLSAUTH_PASSWORD",CURLOPT_PROXY_TLSAUTH_PASSWORD)
                CHECK_CURLOPT("PROXY_TLSAUTH_TYPE",CURLOPT_PROXY_TLSAUTH_TYPE)
                CHECK_CURLOPT("PROXY_SSLCERTTYPE",CURLOPT_PROXY_SSLCERTTYPE)
                CHECK_CURLOPT("PROXY_SSLKEYTYPE",CURLOPT_PROXY_SSLKEYTYPE)
                CHECK_CURLOPT("PROXY_KEYPASSWD",CURLOPT_PROXY_KEYPASSWD)
                CHECK_CURLOPT("PROXY_SSL_CIPHER_LIST",CURLOPT_PROXY_SSL_CIPHER_LIST)
                CHECK_CURLOPT("PRE_PROXY",CURLOPT_PRE_PROXY)
                CHECK_CURLOPT("PROXY_PINNEDPUBLICKEY",CURLOPT_PROXY_PINNEDPUBLICKEY)
                CHECK_CURLOPT("REQUEST_TARGET",CURLOPT_REQUEST_TARGET)
                CHECK_CURLOPT("TLS13_CIPHERS",CURLOPT_TLS13_CIPHERS)
                CHECK_CURLOPT("PROXY_TLS13_CIPHERS",CURLOPT_PROXY_TLS13_CIPHERS)
                CHECK_CURLOPT("DOH_URL",CURLOPT_DOH_URL)
                
                /* encoding */
                CHECK_CURLOPT("ENCODING_IN",CURLOPT_ENCODING_IN)
                CHECK_CURLOPT("ENCODING_OUT",CURLOPT_ENCODING_OUT)
                
                /* path */
                CHECK_CURLOPT("SSLCERT",CURLOPT_SSLCERT)
                CHECK_CURLOPT("COOKIEFILE",CURLOPT_COOKIEFILE)
                CHECK_CURLOPT("CAINFO",CURLOPT_CAINFO)
                CHECK_CURLOPT("COOKIEJAR",CURLOPT_COOKIEJAR)
                CHECK_CURLOPT("SSLKEY",CURLOPT_SSLKEY)
                CHECK_CURLOPT("CAPATH",CURLOPT_CAPATH)
                CHECK_CURLOPT("NETRC_FILE",CURLOPT_NETRC_FILE)
                CHECK_CURLOPT("SSH_PUBLIC_KEYFILE",CURLOPT_SSH_PUBLIC_KEYFILE)
                CHECK_CURLOPT("SSH_PRIVATE_KEYFILE",CURLOPT_SSH_PRIVATE_KEYFILE)
                CHECK_CURLOPT("CRLFILE",CURLOPT_CRLFILE)
                CHECK_CURLOPT("ISSUERCERT",CURLOPT_ISSUERCERT)
                CHECK_CURLOPT("PROXY_CAINFO",CURLOPT_PROXY_CAINFO)
                CHECK_CURLOPT("PROXY_CAPATH",CURLOPT_PROXY_CAPATH)
                CHECK_CURLOPT("PROXY_SSLCERT",CURLOPT_PROXY_SSLCERT)
                CHECK_CURLOPT("PROXY_SSLKEY",CURLOPT_PROXY_SSLKEY)
                CHECK_CURLOPT("PROXY_CRLFILE",CURLOPT_PROXY_CRLFILE)
                
                /* path or value */
                CHECK_CURLOPT("PINNEDPUBLICKEY",CURLOPT_PINNEDPUBLICKEY)
                
                /* longint */
                CHECK_CURLOPT("PORT",CURLOPT_PORT)
                CHECK_CURLOPT("TIMEOUT",CURLOPT_TIMEOUT)
                CHECK_CURLOPT("LOW_SPEED_LIMIT",CURLOPT_LOW_SPEED_LIMIT)
                CHECK_CURLOPT("LOW_SPEED_TIME",CURLOPT_LOW_SPEED_TIME)
                CHECK_CURLOPT("RESUME_FROM",CURLOPT_RESUME_FROM)
                CHECK_CURLOPT("CRLF",CURLOPT_CRLF)
                CHECK_CURLOPT("TIMEVALUE",CURLOPT_TIMEVALUE)
                CHECK_CURLOPT("HEADER",CURLOPT_HEADER)
                CHECK_CURLOPT("NOBODY",CURLOPT_NOBODY)
                CHECK_CURLOPT("FAILONERROR",CURLOPT_FAILONERROR)
                CHECK_CURLOPT("UPLOAD",CURLOPT_UPLOAD)
                CHECK_CURLOPT("POST",CURLOPT_POST)
                CHECK_CURLOPT("DIRLISTONLY",CURLOPT_DIRLISTONLY)
                CHECK_CURLOPT("APPEND",CURLOPT_APPEND)
                CHECK_CURLOPT("NETRC",CURLOPT_NETRC)
                CHECK_CURLOPT("FOLLOWLOCATION",CURLOPT_FOLLOWLOCATION)
                CHECK_CURLOPT("PUT",CURLOPT_PUT)
                CHECK_CURLOPT("AUTOREFERER",CURLOPT_AUTOREFERER)
                CHECK_CURLOPT("PROXYPORT",CURLOPT_PROXYPORT)
                CHECK_CURLOPT("HTTPPROXYTUNNEL",CURLOPT_HTTPPROXYTUNNEL)
                CHECK_CURLOPT("SSL_VERIFYPEER",CURLOPT_SSL_VERIFYPEER)
                CHECK_CURLOPT("MAXREDIRS",CURLOPT_MAXREDIRS)
                CHECK_CURLOPT("FILETIME",CURLOPT_FILETIME)
                CHECK_CURLOPT("MAXCONNECTS",CURLOPT_MAXCONNECTS)
                CHECK_CURLOPT("FRESH_CONNECT",CURLOPT_FRESH_CONNECT)
                CHECK_CURLOPT("FORBID_REUSE",CURLOPT_FORBID_REUSE)
                CHECK_CURLOPT("CONNECTTIMEOUT",CURLOPT_CONNECTTIMEOUT)
                CHECK_CURLOPT("HTTPGET",CURLOPT_HTTPGET)
                CHECK_CURLOPT("SSL_VERIFYHOST",CURLOPT_SSL_VERIFYHOST)
                CHECK_CURLOPT("FTP_USE_EPSV",CURLOPT_FTP_USE_EPSV)
                CHECK_CURLOPT("DNS_CACHE_TIMEOUT",CURLOPT_DNS_CACHE_TIMEOUT)
                CHECK_CURLOPT("COOKIESESSION",CURLOPT_COOKIESESSION)
                CHECK_CURLOPT("BUFFERSIZE",CURLOPT_BUFFERSIZE)
                CHECK_CURLOPT("UNRESTRICTED_AUTH",CURLOPT_UNRESTRICTED_AUTH)
                CHECK_CURLOPT("FTP_USE_EPRT",CURLOPT_FTP_USE_EPRT)
                CHECK_CURLOPT("HTTPAUTH",CURLOPT_HTTPAUTH)
                CHECK_CURLOPT("FTP_CREATE_MISSING_DIRS",CURLOPT_FTP_CREATE_MISSING_DIRS)
                CHECK_CURLOPT("PROXYAUTH",CURLOPT_PROXYAUTH)
                CHECK_CURLOPT("FTP_RESPONSE_TIMEOUT",CURLOPT_FTP_RESPONSE_TIMEOUT)
                CHECK_CURLOPT("IPRESOLVE",CURLOPT_IPRESOLVE)
                CHECK_CURLOPT("MAXFILESIZE",CURLOPT_MAXFILESIZE)
                CHECK_CURLOPT("IGNORE_CONTENT_LENGTH",CURLOPT_IGNORE_CONTENT_LENGTH)
                CHECK_CURLOPT("FTP_SKIP_PASV_IP",CURLOPT_FTP_SKIP_PASV_IP)
                CHECK_CURLOPT("FTP_FILEMETHOD",CURLOPT_FTP_FILEMETHOD)
                CHECK_CURLOPT("LOCALPORT",CURLOPT_LOCALPORT)
                CHECK_CURLOPT("LOCALPORTRANGE",CURLOPT_LOCALPORTRANGE)
                CHECK_CURLOPT("CONNECT_ONLY",CURLOPT_CONNECT_ONLY)
                CHECK_CURLOPT("SSL_SESSIONID_CACHE",CURLOPT_SSL_SESSIONID_CACHE)
                CHECK_CURLOPT("SSH_AUTH_TYPES",CURLOPT_SSH_AUTH_TYPES)
                CHECK_CURLOPT("FTP_SSL_CCC",CURLOPT_FTP_SSL_CCC)
                CHECK_CURLOPT("TIMEOUT_MS",CURLOPT_TIMEOUT_MS)
                CHECK_CURLOPT("CONNECTTIMEOUT_MS",CURLOPT_CONNECTTIMEOUT_MS)
                CHECK_CURLOPT("HTTP_TRANSFER_DECODING",CURLOPT_HTTP_TRANSFER_DECODING)
                CHECK_CURLOPT("HTTP_CONTENT_DECODING",CURLOPT_HTTP_CONTENT_DECODING)
                CHECK_CURLOPT("NEW_FILE_PERMS",CURLOPT_NEW_FILE_PERMS)
                CHECK_CURLOPT("NEW_DIRECTORY_PERMS",CURLOPT_NEW_DIRECTORY_PERMS)
                CHECK_CURLOPT("POSTREDIR",CURLOPT_POSTREDIR)
                CHECK_CURLOPT("PROXY_TRANSFER_MODE",CURLOPT_PROXY_TRANSFER_MODE)
                CHECK_CURLOPT("ADDRESS_SCOPE",CURLOPT_ADDRESS_SCOPE)
                CHECK_CURLOPT("CERTINFO",CURLOPT_CERTINFO)
                CHECK_CURLOPT("TFTP_BLKSIZE",CURLOPT_TFTP_BLKSIZE)
                CHECK_CURLOPT("PROTOCOLS",CURLOPT_PROTOCOLS)
                CHECK_CURLOPT("REDIR_PROTOCOLS",CURLOPT_REDIR_PROTOCOLS)
                CHECK_CURLOPT("FTP_USE_PRET",CURLOPT_FTP_USE_PRET)
                CHECK_CURLOPT("RTSP_REQUEST",CURLOPT_RTSP_REQUEST)
                CHECK_CURLOPT("RTSP_CLIENT_CSEQ",CURLOPT_RTSP_CLIENT_CSEQ)
                CHECK_CURLOPT("RTSP_SERVER_CSEQ",CURLOPT_RTSP_SERVER_CSEQ)
                CHECK_CURLOPT("WILDCARDMATCH",CURLOPT_WILDCARDMATCH)
                CHECK_CURLOPT("TRANSFER_ENCODING",CURLOPT_TRANSFER_ENCODING)
                CHECK_CURLOPT("ACCEPTTIMEOUT_MS",CURLOPT_ACCEPTTIMEOUT_MS)
                CHECK_CURLOPT("TCP_KEEPALIVE",CURLOPT_TCP_KEEPALIVE)
                CHECK_CURLOPT("TCP_KEEPIDLE",CURLOPT_TCP_KEEPIDLE)
                CHECK_CURLOPT("TCP_KEEPINTVL",CURLOPT_TCP_KEEPINTVL)
                CHECK_CURLOPT("SASL_IR",CURLOPT_SASL_IR)
                CHECK_CURLOPT("SSL_ENABLE_NPN",CURLOPT_SSL_ENABLE_NPN)
                CHECK_CURLOPT("SSL_ENABLE_ALPN",CURLOPT_SSL_ENABLE_ALPN)
                CHECK_CURLOPT("EXPECT_100_TIMEOUT_MS",CURLOPT_EXPECT_100_TIMEOUT_MS)
                CHECK_CURLOPT("HEADEROPT",CURLOPT_HEADEROPT)
                CHECK_CURLOPT("SSL_VERIFYSTATUS",CURLOPT_SSL_VERIFYSTATUS)
                CHECK_CURLOPT("SSL_FALSESTART",CURLOPT_SSL_FALSESTART)
                CHECK_CURLOPT("PATH_AS_IS",CURLOPT_PATH_AS_IS)
                CHECK_CURLOPT("PIPEWAIT",CURLOPT_PIPEWAIT)
                CHECK_CURLOPT("STREAM_WEIGHT",CURLOPT_STREAM_WEIGHT)
                CHECK_CURLOPT("TFTP_NO_OPTIONS",CURLOPT_TFTP_NO_OPTIONS)
                CHECK_CURLOPT("TCP_FASTOPEN",CURLOPT_TCP_FASTOPEN)
                CHECK_CURLOPT("KEEP_SENDING_ON_ERROR",CURLOPT_KEEP_SENDING_ON_ERROR)
                CHECK_CURLOPT("PROXY_SSL_VERIFYPEER",CURLOPT_PROXY_SSL_VERIFYPEER)
                CHECK_CURLOPT("PROXY_SSL_VERIFYHOST",CURLOPT_PROXY_SSL_VERIFYHOST)
                CHECK_CURLOPT("PROXY_SSL_OPTIONS",CURLOPT_PROXY_SSL_OPTIONS)
                CHECK_CURLOPT("SUPPRESS_CONNECT_HEADERS",CURLOPT_SUPPRESS_CONNECT_HEADERS)
                CHECK_CURLOPT("SOCKS5_AUTH",CURLOPT_SOCKS5_AUTH)
                CHECK_CURLOPT("SSH_COMPRESSION",CURLOPT_SSH_COMPRESSION)
                CHECK_CURLOPT("HAPPY_EYEBALLS_TIMEOUT_MS",CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS)
                CHECK_CURLOPT("HAPROXYPROTOCOL",CURLOPT_HAPROXYPROTOCOL)
                CHECK_CURLOPT("DNS_SHUFFLE_ADDRESSES",CURLOPT_DNS_SHUFFLE_ADDRESSES)
                CHECK_CURLOPT("DISALLOW_USERNAME_IN_URL",CURLOPT_DISALLOW_USERNAME_IN_URL)
                CHECK_CURLOPT("UPLOAD_BUFFERSIZE",CURLOPT_UPLOAD_BUFFERSIZE)
                CHECK_CURLOPT("UPKEEP_INTERVAL_MS",CURLOPT_UPKEEP_INTERVAL_MS)
                
                /* constant or long */
                CHECK_CURLOPT("USE_SSL",CURLOPT_USE_SSL)
                CHECK_CURLOPT("SSLVERSION",CURLOPT_SSLVERSION)
                CHECK_CURLOPT("HTTP_VERSION",CURLOPT_HTTP_VERSION)
                CHECK_CURLOPT("PROXY_SSLVERSION",CURLOPT_PROXY_SSLVERSION)
                CHECK_CURLOPT("TIMECONDITION",CURLOPT_TIMECONDITION)
                CHECK_CURLOPT("PROXYTYPE",CURLOPT_PROXYTYPE)
                CHECK_CURLOPT("FTPSSLAUTH",CURLOPT_FTPSSLAUTH)
                
                /* array string */
                CHECK_CURLOPT("CONNECT_TO",CURLOPT_CONNECT_TO)
                CHECK_CURLOPT("PROXYHEADER",CURLOPT_PROXYHEADER)
                CHECK_CURLOPT("HTTPHEADER",CURLOPT_HTTPHEADER)
                CHECK_CURLOPT("HTTP200ALIASES",CURLOPT_HTTP200ALIASES)
                CHECK_CURLOPT("RESOLVE",CURLOPT_RESOLVE)
                CHECK_CURLOPT("MAIL_RCPT",CURLOPT_MAIL_RCPT)
                CHECK_CURLOPT("MAIL_FROM",CURLOPT_MAIL_FROM)
                CHECK_CURLOPT("PREQUOTE",CURLOPT_PREQUOTE)
                CHECK_CURLOPT("POSTQUOTE",CURLOPT_POSTQUOTE)
                CHECK_CURLOPT("QUOTE",CURLOPT_QUOTE)
                CHECK_CURLOPT("TELNETOPTIONS",CURLOPT_TELNETOPTIONS)
                
                /* compatibility */
                CHECK_CURLOPT("USE_SSL",CURLOPT_USE_SSL)
                CHECK_CURLOPT("URL",CURLOPT_URL)
                CHECK_CURLOPT("USERNAME",CURLOPT_USERNAME)
                CHECK_CURLOPT("PASSWORD",CURLOPT_PASSWORD)
                CHECK_CURLOPT("FTPPORT",CURLOPT_FTPPORT)
                CHECK_CURLOPT("APPEND",CURLOPT_APPEND)
                CHECK_CURLOPT("FTP_ACCOUNT",CURLOPT_FTP_ACCOUNT)
                CHECK_CURLOPT("PRIVATE",CURLOPT_PRIVATE)
                CHECK_CURLOPT("FTP_USE_EPRT",CURLOPT_FTP_USE_EPRT)
                CHECK_CURLOPT("FTP_USE_EPSV",CURLOPT_FTP_USE_EPSV)
                CHECK_CURLOPT("FTP_USE_PRET",CURLOPT_FTP_USE_PRET)
                CHECK_CURLOPT("FTP_ALTERNATIVE_TO_USER",CURLOPT_FTP_ALTERNATIVE_TO_USER)
                CHECK_CURLOPT("FTP_FILEMETHOD",CURLOPT_FTP_FILEMETHOD)
                CHECK_CURLOPT("TCP_KEEPALIVE",CURLOPT_TCP_KEEPALIVE)
                CHECK_CURLOPT("TCP_KEEPIDLE",CURLOPT_TCP_KEEPIDLE)
                CHECK_CURLOPT("TCP_KEEPINTVL",CURLOPT_TCP_KEEPINTVL)
                CHECK_CURLOPT("FTP_RESPONSE_TIMEOUT",CURLOPT_FTP_RESPONSE_TIMEOUT)
                CHECK_CURLOPT("CONNECTTIMEOUT",CURLOPT_CONNECTTIMEOUT)
                CHECK_CURLOPT("TIMEOUT",CURLOPT_TIMEOUT)
                CHECK_CURLOPT("LOW_SPEED_TIME",CURLOPT_LOW_SPEED_TIME)
                CHECK_CURLOPT("LOW_SPEED_LIMIT",CURLOPT_LOW_SPEED_LIMIT)
                CHECK_CURLOPT("SSL_VERIFYHOST",CURLOPT_SSL_VERIFYHOST)
                CHECK_CURLOPT("SSL_VERIFYPEER",CURLOPT_SSL_VERIFYPEER)
                CHECK_CURLOPT("CAINFO",CURLOPT_CAINFO)
                CHECK_CURLOPT("FTPSSLAUTH",CURLOPT_FTPSSLAUTH)
                CHECK_CURLOPT("FTP_SSL_CCC",CURLOPT_FTP_SSL_CCC)
                CHECK_CURLOPT("SSH_AUTH_TYPES",CURLOPT_SSH_AUTH_TYPES)
                CHECK_CURLOPT("SSH_COMPRESSION",CURLOPT_SSH_COMPRESSION)
                CHECK_CURLOPT("SSH_HOST_PUBLIC_KEY_MD5",CURLOPT_SSH_HOST_PUBLIC_KEY_MD5)
                CHECK_CURLOPT("SSH_PUBLIC_KEYFILE",CURLOPT_SSH_PUBLIC_KEYFILE)
                CHECK_CURLOPT("SSH_PRIVATE_KEYFILE",CURLOPT_SSH_PRIVATE_KEYFILE)
                CHECK_CURLOPT("SSH_KNOWNHOSTS",CURLOPT_SSH_KNOWNHOSTS)
                CHECK_CURLOPT("UPKEEP_INTERVAL_MS",CURLOPT_UPKEEP_INTERVAL_MS)
                CHECK_CURLOPT("DISALLOW_USERNAME_IN_URL",CURLOPT_DISALLOW_USERNAME_IN_URL)
                CHECK_CURLOPT("PROXY_TLS13_CIPHERS",CURLOPT_PROXY_TLS13_CIPHERS)
                CHECK_CURLOPT("TLS13_CIPHERS",CURLOPT_TLS13_CIPHERS)
                CHECK_CURLOPT("DNS_SHUFFLE_ADDRESSES",CURLOPT_DNS_SHUFFLE_ADDRESSES)
                CHECK_CURLOPT("HAPROXYPROTOCOL",CURLOPT_HAPROXYPROTOCOL)
                CHECK_CURLOPT("DOH_URL",CURLOPT_DOH_URL)
                CHECK_CURLOPT("UPLOAD_BUFFERSIZE",CURLOPT_UPLOAD_BUFFERSIZE)
                CHECK_CURLOPT("HAPPY_EYEBALLS_TIMEOUT_MS",CURLOPT_HAPPY_EYEBALLS_TIMEOUT_MS)
                
            json_get_curl_option_exit:

                (void)0;

            }
    
    return v;
}

CURLcode curl_perform(CURLM *mcurl, CURL *curl, C_TEXT& Param4, C_TEXT& userInfo) {
    
    /* callback argument or return value if method name is empty */
    
    CUTF16String info;
    CURLMcode mc = CURLM_OK; /* not used to abort */
    CURLcode result = CURLE_OK;
    
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
#if USE_PA_EXECUTE_METHOD_BY_ID
    PA_long32 method_id = PA_GetMethodID((PA_Unichar *)Param4.getUTF16StringPtr());
#else
    PA_long32 method_id = 0;
#endif
    
    time_t startTime = time(0);
    
    bool isCallbackSet = Param4.getUTF16Length();
    
    PA_Variable    cbparams[4];
    
    if(method_id)
    {
        cbparams[0] = PA_CreateVariable(eVK_Unistring);
        cbparams[1] = PA_CreateVariable(eVK_Unistring);
        cbparams[2] = PA_CreateVariable(eVK_Undefined);
        cbparams[3] = PA_CreateVariable(eVK_Undefined);
        PA_SetUnistring((&(cbparams[1].uValue.fString)),
                        (PA_Unichar *)userInfo.getUTF16StringPtr());
    }else
    {
        cbparams[0] = PA_CreateVariable(eVK_Unistring);
        cbparams[1] = PA_CreateVariable(eVK_Boolean);
        cbparams[2] = PA_CreateVariable(eVK_Unistring);
        cbparams[3] = PA_CreateVariable(eVK_Unistring);
        PA_SetUnistring((&(cbparams[0].uValue.fString)),
                        (PA_Unichar *)Param4.getUTF16StringPtr());
        PA_SetUnistring((&(cbparams[3].uValue.fString)),
                        (PA_Unichar *)userInfo.getUTF16StringPtr());
    }
    
    int running_handles = 0;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        curl_multi_add_handle(mcurl, curl);
        curl_multi_perform(mcurl, &running_handles);
    }
    
    do
    {
        PA_YieldAbsolute();
        
        struct timeval tv;
        int rc = 0;
        
        fd_set fdread;
        fd_set fdwrite;
        fd_set fdexcep;
        
        int maxfd = -1;
        long curl_timeout = -1;
        
        FD_ZERO(&fdread);
        FD_ZERO(&fdwrite);
        FD_ZERO(&fdexcep);
        
        tv.tv_sec = 1;
        tv.tv_usec = 0;
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(mutexMcurl);
            
            curl_multi_timeout(mcurl, &curl_timeout);
            
            if(curl_timeout >= 0)
            {
                tv.tv_sec = curl_timeout / 1000;
                if(tv.tv_sec > 1)
                    tv.tv_sec = 1;
                else
                    tv.tv_usec = (curl_timeout % 1000) * 1000;
            }
            
            mc = curl_multi_fdset(mcurl, &fdread, &fdwrite, &fdexcep, &maxfd);
        }
        
        if(mc != CURLM_OK)
        {
            break;
        }
        
        if(maxfd == -1)
        {
            /* https://curl.haxx.se/libcurl/c/multi-post.html */
            
            PA_Variable params[2];
            params[0] = PA_CreateVariable(eVK_Longint);
            PA_SetLongintVariable(&params[0], currentProcessNumber);
            
            params[1] = PA_CreateVariable(eVK_Real);
            PA_SetRealVariable(&params[1], 6);//100ms
            
            PA_ExecuteCommandByID(323 /*DELAY_PROCESS*/ , params, 2);
            
            PA_ClearVariable(&params[0]);
            PA_ClearVariable(&params[1]);
            
            rc = 0;
        }
        else
        {
            rc = select(maxfd+1, &fdread, &fdwrite, &fdexcep, &tv);
        }
        switch(rc) {
            case -1:
                /* select error */
                break;
            case 0:
            default:
                if(1)
                {
                    std::lock_guard<std::mutex> lock(mutexMcurl);
                    
                    /* timeout or readable/writable sockets */
                    mc = curl_multi_perform(mcurl, &running_handles);
                    /* callback method */
                }
            {
                
                time_t now = time(0);
                time_t elapsedTime = abs(startTime - now);
                
                if(elapsedTime > 0)
                {
                    startTime = now;
                    
                    if(isCallbackSet)
                    {
                        
                        time_t now = time(0);
                        time_t elapsedTime = abs(startTime - now);
                        if(elapsedTime > 0)
                        {
                            startTime = now;
                            
                            if(1)
                            {
                                std::lock_guard<std::mutex> lock(mutexMcurl);
                                
                                curl_get_info(curl, info);
                            }
                            if(method_id)
                            {
                                PA_SetUnistring((&(cbparams[0].uValue.fString)),
                                                (PA_Unichar *)info.c_str());
                                
                                PA_Variable statusCode = PA_ExecuteMethodByID(method_id, cbparams, 2);
                                if(PA_GetVariableKind(statusCode) == eVK_Boolean)
                                {
                                    if(PA_GetBooleanVariable(statusCode))
                                    {
                                        /* abort */
                                        result = CURLE_ABORTED_BY_CALLBACK;
                                        goto curl_abort_transfer;
                                    }
                                }
                            }else
                            {
                                PA_SetUnistring((&(cbparams[2].uValue.fString)),
                                                (PA_Unichar *)info.c_str());
                                
                                PA_SetBooleanVariable(&cbparams[1], false);
                                PA_ExecuteCommandByID(1007, cbparams, 4);
                                if(PA_GetBooleanVariable(cbparams[1]))
                                {
                                    /* abort */
                                    result = CURLE_ABORTED_BY_CALLBACK;
                                    goto curl_abort_transfer;
                                }
                            }
                        }
                    }else
                    {
                        PA_YieldAbsolute();
                    }
                }
                
                PA_Variable params;
                bool isProcessDying = PA_GetBooleanVariable(PA_ExecuteCommandByID(672/* Process aborted */, &params, 0));
                /* PA_IsProcessDying is not threadSafe */
                
                if(isProcessDying)
                {
                    /* abort (runtime explorer, not debugger) */
                    result = CURLE_ABORTED_BY_CALLBACK;
                    goto curl_abort_transfer;
                }
                
            }
                break;
        }
        
    }while((running_handles));
    
curl_abort_transfer:
    
    PA_ClearVariable(&cbparams[0]);
    PA_ClearVariable(&cbparams[1]);
    PA_ClearVariable(&cbparams[2]);
    PA_ClearVariable(&cbparams[3]);
    
    struct CURLMsg *m;
    int msgq = 0;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        m = curl_multi_info_read(mcurl, &msgq);
        if(m && (m->msg == CURLMSG_DONE))
        {
            result = m->data.result;
        }
        
        if(!Param4.getUTF16Length())
        {
            curl_get_info(curl, info);
            Param4.setUTF16String(&info);
        }
        
        curl_multi_remove_handle(mcurl, curl);
    }
    
    return result;
}

#pragma mark -

bool create_folder(path_t *absolute_path) {
    
    bool success = false;
    
#if VERSIONMAC
    NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    NSFileManager *fm = [[NSFileManager alloc]init];
    success = [fm createDirectoryAtPath:path
            withIntermediateDirectories:YES
                             attributes:nil
                                  error:NULL];
    [path release];
    [fm release];
#else
    success = SHCreateDirectory(NULL, (PCWSTR)absolute_path);
#endif
    
    return success;
}

void create_parent_folder(path_t *absolute_path) {
    
#if VERSIONMAC
    NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
    absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
    create_folder((path_t *)folderPath.c_str());
    [filePath release];
#else
    wchar_t    fDrive[_MAX_DRIVE],
    fDir[_MAX_DIR],
    fName[_MAX_FNAME],
    fExt[_MAX_EXT];
    _wsplitpath_s(absolute_path, fDrive, fDir, fName, fExt);
    absolute_path_t folderPath = fDrive;
    folderPath += fDir;
    create_folder((path_t *)folderPath.c_str());
#endif
}

size_t curl_header_function_for_system(void *buffer,
                                       size_t size,
                                       size_t nmemb,
                                       CUTF8String& system) {
    
    size_t len = size * nmemb;
    std::string line = std::string((const char *)buffer, len);
    
    /* Reply format is like
     215<space><OS-name><space><commentary>
     */
    
    if(line.find("215 ") == 0)
    {
        size_t length = line.length() -4;
        for(size_t i = length + 3; i > 0; --i)
        {
            if(line.compare(i, 1, "\n") == 0)
            {
                length--;continue;
            }
            if(line.compare(i, 1, "\r") == 0)
            {
                length--;continue;
            }
            break;
        }
        
        system = CUTF8String((const uint8_t *)line.substr(4).c_str(), length);
    }
    
    return len;
}

size_t curl_header_function_for_fileinfo(void *buffer,
                                         size_t size,
                                         size_t nmemb,
                                         CUTF8String& fileSize) {
    
    size_t len = size * nmemb;
    std::string line = std::string((const char *)buffer, len);
    
    /* Reply format is like (File status)
     213<space><size>
     */
    
    if(line.find("213 ") == 0)
    {
        size_t length = line.length() -4;
        for(size_t i = length + 3; i > 0; --i)
        {
            if(line.compare(i, 1, "\n") == 0)
            {
                length--;continue;
            }
            if(line.compare(i, 1, "\r") == 0)
            {
                length--;continue;
            }
            break;
        }
        
        fileSize = CUTF8String((const uint8_t *)line.substr(4).c_str(), length);
    }
    
    return len;
}

size_t curl_debug_function(CURL *curl,
                           curl_infotype type,
                           char *data,
                           size_t size,
                           http_debug_ctx *ctx) {
       
#if VERSIONMAC
    std::string path;
    path = std::string(ctx->path);
#else
    std::wstring path;
    path = std::wstring(ctx->path);
#endif
    
    curl_off_t  *f_size = NULL;

    switch (type)
    {
        case CURLINFO_TEXT:
            path += LOG_CURLINFO_TEXT;
            f_size = &ctx->size_CURLINFO_TEXT;
            break;
        case CURLINFO_HEADER_IN:
            path += LOG_CURLINFO_HEADER_IN;
            f_size = &ctx->size_CURLINFO_HEADER_IN;
            break;
        case CURLINFO_HEADER_OUT:
            path += LOG_CURLINFO_HEADER_OUT;
            f_size = &ctx->size_CURLINFO_HEADER_OUT;
            break;
        case CURLINFO_DATA_IN:
            path += LOG_CURLINFO_DATA_IN;
            f_size = &ctx->size_CURLINFO_DATA_IN;
            break;
        case CURLINFO_DATA_OUT:
            path += LOG_CURLINFO_DATA_OUT;
            f_size = &ctx->size_CURLINFO_DATA_OUT;
            break;
        case CURLINFO_SSL_DATA_OUT:
            path += LOG_CURLINFO_SSL_DATA_IN;
            f_size = &ctx->size_CURLINFO_SSL_DATA_IN;
            break;
        case CURLINFO_SSL_DATA_IN:
            path += LOG_CURLINFO_SSL_DATA_OUT;
            f_size = &ctx->size_CURLINFO_SSL_DATA_OUT;
            break;
        default:
            break;
    }

    create_parent_folder((path_t *)path.c_str());
     
    FILE *f = CPathOpen ((path_t *)path.c_str(), *f_size ? CPathAppend : CPathCreate);
    
    if(f)
    {
        *f_size += size;
        fwrite(data, size, sizeof(char), f);
        fclose(f);
    }

    return 0;
}

size_t curl_write_function_for_text(void *buffer,
                                    size_t size,
                                    size_t nmemb,
                                    CUTF8String& text) {
    
    size_t len = size * nmemb;
    text.append((const uint8_t *)buffer, len);
    
    return len;
}

size_t curl_read_function_for_path(void *buffer,
                                   size_t size,
                                   size_t nmemb,
                                   path_ctx *ctx) {
    
    size_t len = size * nmemb;
    FILE *f;
    
    f = CPathOpen (ctx->path, CPathRead);
    
    if(f)
    {
        fseek(f, ctx->pos, SEEK_SET);
        len = fread(buffer, size, nmemb, f);
        ctx->pos += len;
        fclose(f);
    }else
    {
        len = 0;/* file not found */
    }
    
    return len;
}

size_t curl_write_function_for_path(void *buffer,
                                    size_t size,
                                    size_t nmemb,
                                    path_ctx *ctx) {
    
    size_t len = size * nmemb;
    
    if(ctx->useWildCard)
    {
        if(ctx->f)
        {
            fwrite(buffer, size, nmemb, ctx->f);
        }else
        {
            len = 0;
        }
    }else
    {
        create_parent_folder((path_t *)ctx->path);
        FILE *f = CPathOpen (ctx->path, ctx->shouldAppend ? CPathAppend : CPathCreate);
        ctx->shouldAppend = TRUE;
        
        if(f)
        {
            fwrite(buffer, size, nmemb, f);
            fclose(f);
        }else
        {
            len = 0;
        }
    }
    
    return len;
}

size_t curl_chunk_bgn_function(struct curl_fileinfo *finfo,
                               path_ctx *ctx,
                               int remains) {
    
    absolute_path_t path = absolute_path_t(ctx->dir);
    
#if VERSIONMAC
    absolute_path_t filename = absolute_path_t(finfo->filename);
#else
    C_TEXT t;
    t.setUTF8String((const uint8_t *)finfo->filename, strlen(finfo->filename));
    absolute_path_t filename = (const wchar_t *)t.getUTF16StringPtr();
#endif
    
    if((finfo->filetype) == CURLFILETYPE_FILE)
    {
        
//        ctx->path = path.append(filename).c_str();
        path.append(filename);
        
        memset(ctx->path, 0x00, MAX_LENGTH_FOR_PATH * sizeof(path_t));
        memcpy(ctx->path, path.c_str(), path.length() * sizeof(path_t));
        
        create_parent_folder((path_t *)ctx->path);
        ctx->f = CPathOpen (ctx->path, CPathCreate);
        if(!ctx->f)
        {
            return CURL_CHUNK_BGN_FUNC_FAIL;
        }
    }
    
    return CURL_CHUNK_BGN_FUNC_OK;
}

size_t curl_chunk_end_function(path_ctx *ctx) {
    
    if(ctx->f)
    {
        fclose(ctx->f);
        ctx->f = NULL;
    }
    
    return CURL_CHUNK_END_FUNC_OK;
}

