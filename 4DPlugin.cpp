/* --------------------------------------------------------------------------------
 #
 #	4DPlugin.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : cURL FTP
 #	author : miyako
 #	2017/12/13
 #
 # --------------------------------------------------------------------------------*/


#include "4DPluginAPI.h"
#include "4DPlugin.h"

std::mutex mutexMcurl;
std::mutex mutexJson;

CURLM *gmcurl = NULL;

/*
bool IsProcessOnExit()
{
	C_TEXT name;
	PA_long32 state, time;
	PA_GetProcessInfo(PA_GetCurrentProcessNumber(), name, &state, &time);
	CUTF16String procName(name.getUTF16StringPtr());
	CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
	return (!procName.compare(exitProcName));
}
*/

void OnStartup()
{
	curl_global_init(CURL_GLOBAL_DEFAULT);
	
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        gmcurl = curl_multi_init();
    }
}

void OnExit()
{
    if(gmcurl)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        curl_multi_cleanup(gmcurl);
        gmcurl = NULL;
    }
    
    curl_global_cleanup();
}

/*
void OnCloseProcess()
{
 if(IsProcessOnExit())
 {
 OnExit();
 }
}
*/

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params)
{
	try
	{
		PA_long32 pProcNum = selector;
		sLONG_PTR *pResult = (sLONG_PTR *)params->fResult;
		PackagePtr pParams = (PackagePtr)params->fParameters;

		CommandDispatcher(pProcNum, pResult, pParams); 
	}
	catch(...)
	{

	}
}

void CommandDispatcher (PA_long32 pProcNum, sLONG_PTR *pResult, PackagePtr pParams)
{
	switch(pProcNum)
	{
		case kInitPlugin :
		case kServerInitPlugin :
			OnStartup();
			break;
            
        case kDeinitPlugin :
            OnExit();
            break;
			
        /*
		case kCloseProcess :
			OnCloseProcess();
			break;
         */
			// --- FTP

		case 1 :
			cURL_FTP_Delete(pResult, pParams);
			break;

		case 2 :
			cURL_FTP_GetDirList(pResult, pParams);
			break;

		case 3 :
			cURL_FTP_GetFileInfo(pResult, pParams);
			break;

		case 4 :
			cURL_FTP_MakeDir(pResult, pParams);
			break;

		case 5 :
			cURL_FTP_PrintDir(pResult, pParams);
			break;

		case 6 :
			cURL_FTP_Receive(pResult, pParams);
			break;

		case 7 :
			cURL_FTP_RemoveDir(pResult, pParams);
			break;

		case 8 :
			cURL_FTP_Rename(pResult, pParams);
			break;

		case 9 :
			cURL_FTP_Send(pResult, pParams);
			break;

		case 10 :
			cURL_FTP_System(pResult, pParams);
			break;

	}
}

// -------------------------------------- FTP -------------------------------------

#pragma mark -

CURLcode curl_perform(CURLM *mcurl, CURL *curl, C_TEXT& Param4, C_TEXT& userInfo)
{
	/* callback argument or return value if method name is empty */
	CUTF16String info;
	CURLMcode mc = CURLM_OK; /* not used to abort */
	CURLcode result = CURLE_OK;
	
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber2();
    
	/* prepare for callback */
	PA_Variable	params[4];
    PA_long32 method_id = 0;//PA_GetMethodID((PA_Unichar *)Param4.getUTF16StringPtr());
	
	if(method_id)
	{
		params[0] = PA_CreateVariable(eVK_Unistring);
		params[1] = PA_CreateVariable(eVK_Unistring);
		params[2] = PA_CreateVariable(eVK_Undefined);
		params[3] = PA_CreateVariable(eVK_Undefined);
		PA_SetUnistring((&(params[1].uValue.fString)),
										(PA_Unichar *)userInfo.getUTF16StringPtr());
	}else
	{
		params[0] = PA_CreateVariable(eVK_Unistring);
		params[1] = PA_CreateVariable(eVK_Boolean);
		params[2] = PA_CreateVariable(eVK_Unistring);
		params[3] = PA_CreateVariable(eVK_Unistring);
		PA_SetUnistring((&(params[0].uValue.fString)),
										(PA_Unichar *)Param4.getUTF16StringPtr());
		PA_SetUnistring((&(params[3].uValue.fString)),
										(PA_Unichar *)userInfo.getUTF16StringPtr());
	}
	int running_handles = 0;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        curl_multi_add_handle(mcurl, curl);
        curl_multi_perform(mcurl, &running_handles);
    }
	
	do
	{
		PA_YieldAbsolute2();
		
		struct timeval tv;
		int rc = 0;
		
		fd_set fdread;
		fd_set fdwrite;
		fd_set fdexcep;
		
		int maxfd = -1;
		long curl_timeout = -1;
		
		FD_ZERO(&fdread);
		FD_ZERO(&fdwrite);
		FD_ZERO(&fdexcep);
		
		tv.tv_sec = 1;
		tv.tv_usec = 0;
		
        if(1)
        {
            std::lock_guard<std::mutex> lock(mutexMcurl);
            
            curl_multi_timeout(mcurl, &curl_timeout);
            
            if(curl_timeout >= 0)
            {
                tv.tv_sec = curl_timeout / 1000;
                if(tv.tv_sec > 1)
                    tv.tv_sec = 1;
                else
                    tv.tv_usec = (curl_timeout % 1000) * 1000;
            }
            
            mc = curl_multi_fdset(mcurl, &fdread, &fdwrite, &fdexcep, &maxfd);
        }
        
		if(mc != CURLM_OK)
		{
			break;
		}
		
		if(maxfd == -1)
		{
			/* https://curl.haxx.se/libcurl/c/multi-post.html */
			PA_PutProcessToSleep2(PA_GetCurrentProcessNumber(), 6);//100ms
			rc = 0;
		}
		else
		{
			rc = select(maxfd+1, &fdread, &fdwrite, &fdexcep, &tv);
		}
		switch(rc) {
			case -1:
				/* select error */
				break;
			case 0:
			default:
            if(1)
            {
                std::lock_guard<std::mutex> lock(mutexMcurl);
                
                /* timeout or readable/writable sockets */
                mc = curl_multi_perform(mcurl, &running_handles);
                /* callback method */
            }
                
			{
                if(1)
                {
                    std::lock_guard<std::mutex> lock(mutexMcurl);
                    
                    curl_get_info(curl, info);
                }
				
				if(Param4.getUTF16Length())
				{
					if(method_id)
					{
						PA_SetUnistring((&(params[0].uValue.fString)),
														(PA_Unichar *)info.c_str());
						
						PA_Variable statusCode = PA_ExecuteMethodByID(method_id, params, 2);
						if(PA_GetVariableKind(statusCode) == eVK_Boolean)
						{
							if(PA_GetBooleanVariable(statusCode))
							{
								/* abort */
								result = CURLE_ABORTED_BY_CALLBACK;
								goto curl_abort_transfer;
							}
						}
					}else
					{
						PA_SetUnistring((&(params[2].uValue.fString)),
														(PA_Unichar *)info.c_str());
						
						PA_SetBooleanVariable(&params[1], false);
						PA_ExecuteCommandByID(1007, params, 4);
						if(PA_GetBooleanVariable(params[1]))
						{
							/* abort */
							result = CURLE_ABORTED_BY_CALLBACK;
							goto curl_abort_transfer;
						}
					}
					
				}
				
				if(PA_IsProcessDying2())
				{
					/* abort (runtime explorer, not debugger) */
					result = CURLE_ABORTED_BY_CALLBACK;
					goto curl_abort_transfer;
				}
				
			}
				break;
		}
		
	}while((running_handles));
	
curl_abort_transfer:
	
	PA_ClearVariable(&params[0]);
	PA_ClearVariable(&params[1]);
	PA_ClearVariable(&params[2]);
	PA_ClearVariable(&params[3]);
	
	struct CURLMsg *m;
	int msgq = 0;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(mutexMcurl);
        
        m = curl_multi_info_read(mcurl, &msgq);
        if(m && (m->msg == CURLMSG_DONE))
        {
            result = m->data.result;
        }
        
        if(!Param4.getUTF16Length())
        {
            curl_get_info(curl, info);
            Param4.setUTF16String(&info);
        }
        
        curl_multi_remove_handle(mcurl, curl);
    }
	
	return result;
}

#pragma mark -

void cURL_FTP_Delete(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);

	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path);
	
	curl_unescape_path(curl, path);
	
	CUTF8String fullpath = path;
	
	curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
	
	struct curl_slist *h = NULL;
	
	last_path_component(path);/* because we use CURLOPT_POSTQUOTE */
	
	CUTF8String quote;
	
	switch (protocol) {
  case PROTOCOL_TYPE_SFTP:
			quote = CUTF8String((const uint8_t *)"rm ").append(fullpath);
			break;
			
  default:
			quote = CUTF8String((const uint8_t *)"DELE ").append(path);
			break;
	}

	h = curl_slist_append(h, (const char *)quote.c_str());
	
	curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
	
	returnValue.setIntValue(curl_perform(mcurl, curl, Param2, userInfo));
	
	curl_slist_free_all(h);
	
	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void cURL_FTP_MakeDir(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_LONGINT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path);
	
	curl_unescape_path(curl, path);
	
	curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);

	struct curl_slist *h = NULL;
	
	if(Param2.getIntValue())
	{
		curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, CURLFTP_CREATE_DIR_RETRY);
	}
	
	CUTF8String quote;
	
	switch (protocol) {
  case PROTOCOL_TYPE_SFTP:
			quote = CUTF8String((const uint8_t *)"mkdir ").append(path);
			h = curl_slist_append(h, (const char *)quote.c_str());
			break;
			
  default:
			quote = CUTF8String((const uint8_t *)"MKD ").append(path);
			h = curl_slist_append(h, (const char *)quote.c_str());
			break;
	}
	
	curl_easy_setopt(curl, CURLOPT_QUOTE, h);
	
	returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
	
	curl_slist_free_all(h);
	
	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param3.toParamAtIndex(pParams, 3);
	returnValue.setReturn(pResult);
}

void cURL_FTP_RemoveDir(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path);
	
	curl_unescape_path(curl, path);
	
	CUTF8String fullpath = path;
	
	curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
	
	struct curl_slist *h = NULL;

	last_path_component(path);/* because we CURLOPT_POSTQUOTE */
	
	CUTF8String quote;
	
	switch (protocol) {
  case PROTOCOL_TYPE_SFTP:
			quote = CUTF8String((const uint8_t *)"rmdir ").append(fullpath + (const uint8_t *)"/");
			h = curl_slist_append(h, (const char *)quote.c_str());

			break;
			
  default:
			quote = CUTF8String((const uint8_t *)"RMD ").append(path);
			h = curl_slist_append(h, (const char *)quote.c_str());
			break;
	}
	
	curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
	
	returnValue.setIntValue(curl_perform(mcurl, curl, Param2, userInfo));
	
	curl_slist_free_all(h);
	
	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param2.toParamAtIndex(pParams, 2);
	returnValue.setReturn(pResult);
}

void cURL_FTP_Rename(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	protocol_type_t protocol = curl_set_options(curl, Param1, userInfo, path);
	
	curl_unescape_path(curl, path);
	
	CUTF8String fullpath = path;
	
	curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
	
	struct curl_slist *h = NULL;
	
	last_path_component(path);
	
	remove_trailing_separator(path);
	
	CUTF8String name;
	Param2.copyUTF8String(&name);
		
	CUTF8String quote;
	
	switch (protocol) {
  case PROTOCOL_TYPE_SFTP:
			quote = CUTF8String((const uint8_t *)"rename ")
			.append(fullpath)
			.append((const uint8_t *)" ")
			.append(name);
			h = curl_slist_append(h, (const char *)quote.c_str());
			break;
			
  default:
			quote = CUTF8String((const uint8_t *)"RNFR ").append(path);
			h = curl_slist_append(h, (const char *)quote.c_str());
			
			quote = CUTF8String((const uint8_t *)"RNTO ").append(name);
			h = curl_slist_append(h, (const char *)quote.c_str());
			break;
	}
	
	curl_easy_setopt(curl, CURLOPT_POSTQUOTE, h);
	
	returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
	
	curl_slist_free_all(h);
	
	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param3.toParamAtIndex(pParams, 3);
	returnValue.setReturn(pResult);
}

#pragma mark -

bool create_folder(path_t *absolute_path){
	
	bool success = false;
	
#if VERSIONMAC
	NSString *path = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
	NSFileManager *fm = [[NSFileManager alloc]init];
	success = [fm createDirectoryAtPath:path
					withIntermediateDirectories:YES
													 attributes:nil
																error:NULL];
	[path release];
	[fm release];
#else
	success = SHCreateDirectory(NULL, (PCWSTR)absolute_path);
#endif
	
	return success;
}

void create_parent_folder(path_t *absolute_path){
#if VERSIONMAC
	NSString *filePath = (NSString *)CFStringCreateWithFileSystemRepresentation(kCFAllocatorDefault, absolute_path);
	absolute_path_t folderPath = absolute_path_t([[filePath stringByDeletingLastPathComponent]fileSystemRepresentation]);
	create_folder((path_t *)folderPath.c_str());
	[filePath release];
#else
	wchar_t	fDrive[_MAX_DRIVE],
	fDir[_MAX_DIR],
	fName[_MAX_FNAME],
	fExt[_MAX_EXT];
	_wsplitpath_s(absolute_path, fDrive, fDir, fName, fExt);
	absolute_path_t folderPath = fDrive;
	folderPath += fDir;
	create_folder((path_t *)folderPath.c_str());
#endif
}

#pragma mark download

size_t curl_write_function_for_path(void *buffer,
																		size_t size,
																		size_t nmemb,
																		path_ctx *ctx)
{
	size_t len = size * nmemb;

	if(ctx->useWildCard)
	{
		if(ctx->f)
		{
			fwrite(buffer, size, nmemb, ctx->f);
		}else
		{
			len = 0;
		}
	}else
	{
		create_parent_folder((path_t *)ctx->path);
		FILE *f = CPathOpen (ctx->path, ctx->shouldAppend ? CPathAppend : CPathCreate);
		ctx->shouldAppend = TRUE;
		
		if(f)
		{
			fwrite(buffer, size, nmemb, f);
			fclose(f);
		}else
		{
			len = 0;
		}
	}
	
	return len;
}

size_t curl_chunk_bgn_function(struct curl_fileinfo *finfo,
															 path_ctx *ctx,
															 int remains)
{
	absolute_path_t path = absolute_path_t(ctx->dir);
	
#if VERSIONMAC
	absolute_path_t filename = absolute_path_t(finfo->filename);
#else
	C_TEXT t;
	t.setUTF8String((const uint8_t *)finfo->filename, strlen(finfo->filename));
	absolute_path_t filename = (const wchar_t *)t.getUTF16StringPtr();
#endif
	
	if((finfo->filetype) == CURLFILETYPE_FILE)
	{
		ctx->path = path.append(filename).c_str();
		create_parent_folder((path_t *)ctx->path);
		ctx->f = CPathOpen (ctx->path, CPathCreate);
		if(!ctx->f)
		{
			return CURL_CHUNK_BGN_FUNC_FAIL;
		}
	}
	
	return CURL_CHUNK_BGN_FUNC_OK;
}

size_t curl_chunk_end_function(path_ctx *ctx)
{
	if(ctx->f)
	{
		fclose(ctx->f);
		ctx->f = NULL;
	}
	
	return CURL_CHUNK_END_FUNC_OK;
}

void cURL_FTP_Receive(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	curl_set_options(curl, Param1, userInfo, path);
	
	path_ctx ctx;
	ctx.f = NULL;
	ctx.useWildCard = FALSE;
	ctx.shouldAppend = FALSE;
	ctx.path = NULL;
	ctx.dir = NULL;
	
	CPathString local_path;
	
#if VERSIONMAC
	Param2.copyPath(&local_path);
	remove_trailing_separator(local_path);
	ctx.path = (const char *)local_path.c_str();
#else
	local_path = Param2.getUTF16StringPtr();
	remove_trailing_separator(local_path);
	ctx.path = (const wchar_t *)local_path.c_str();
#endif
	
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
	
	if(Param3.getIntValue())
	{
		ctx.useWildCard =TRUE;
		curl_easy_setopt(curl, CURLOPT_WILDCARDMATCH, 1L);
		curl_easy_setopt(curl, CURLOPT_CHUNK_BGN_FUNCTION, curl_chunk_bgn_function);
		curl_easy_setopt(curl, CURLOPT_CHUNK_END_FUNCTION, curl_chunk_end_function);
		curl_easy_setopt(curl, CURLOPT_CHUNK_DATA, &ctx);
#if VERSIONMAC
		local_path += folder_separator;
		ctx.dir = (const char *)local_path.c_str();
#else
		local_path += folder_separator;
		ctx.dir = (const wchar_t *)local_path.c_str();
#endif
	}
	
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &ctx);
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_path);

	returnValue.setIntValue(curl_perform(mcurl, curl, Param4, userInfo));
	
	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param4.toParamAtIndex(pParams, 4);
	
	returnValue.setReturn(pResult);
}

#pragma mark upload

size_t curl_read_function_for_path(void *buffer,
																		size_t size,
																		size_t nmemb,
																		path_ctx *ctx)
{
	size_t len = size * nmemb;
	FILE *f;
	
	f = CPathOpen (ctx->path, CPathRead);
	
	if(f)
	{
		fseek(f, ctx->pos, SEEK_SET);
		len = fread(buffer, size, nmemb, f);
		ctx->pos += len;
		fclose(f);
	}else
	{
		len = 0;/* file not found */
	}
	
	return len;
}

void cURL_FTP_Send(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_LONGINT Param3;
	C_TEXT Param4;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	Param4.fromParamAtIndex(pParams, 4);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	curl_set_options(curl, Param1, userInfo, path);
	
	path_ctx ctx;
	ctx.pos = 0L;
	
	CPathString local_path;
#if VERSIONMAC
	Param2.copyPath(&local_path);
	ctx.path = (const char *)local_path.c_str();
#else
	local_path = Param2.getUTF16StringPtr();
	ctx.path = (const wchar_t *)local_path.c_str();
#endif
	
	/* file size */
	curl_off_t fileSize = 0L;
	FILE *f = CPathOpen (ctx.path, CPathRead);
	if(f)
	{
		fseek(f, 0L, SEEK_END);
		fileSize = (curl_off_t)ftell(f);
		fclose(f);
		
		if(fileSize != -1L)
		{
			curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE_LARGE, fileSize);
		}
		
		if(Param3.getIntValue())
		{
			curl_easy_setopt(curl, CURLOPT_FTP_CREATE_MISSING_DIRS, CURLFTP_CREATE_DIR_RETRY);
		}
		
		curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);
		
		curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
		curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
		curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
		
		curl_easy_setopt(curl, CURLOPT_READDATA, &ctx);
		curl_easy_setopt(curl, CURLOPT_READFUNCTION, curl_read_function_for_path);
		
		returnValue.setIntValue(curl_perform(mcurl, curl, Param4, userInfo));
	}

	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param4.toParamAtIndex(pParams, 4);
	returnValue.setReturn(pResult);
}

#pragma mark -


#pragma mark dirlist

size_t curl_write_function_for_text(void *buffer,
																		size_t size,
																		size_t nmemb,
																		CUTF8String& text)
{
	size_t len = size * nmemb;
	text.append((const uint8_t *)buffer, len);
	
	return len;
}

void cURL_FTP_GetDirList(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param3.fromParamAtIndex(pParams, 3);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	curl_set_options(curl, Param1, userInfo, path);
	
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
	
	/* body */
	CUTF8String dirlist;
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &dirlist);
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_text);
	curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, "LIST");
	
	returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
	
	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param2.setUTF8String(&dirlist);
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	
	returnValue.setReturn(pResult);
}

void cURL_FTP_PrintDir(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param3.fromParamAtIndex(pParams, 3);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	curl_set_options(curl, Param1, userInfo, path);
	
	curl_easy_setopt(curl, CURLOPT_NOBODY, 0L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
	
	/* body */
	CUTF8String dirlist;
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, &dirlist);
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, curl_write_function_for_text);	
	curl_easy_setopt(curl, CURLOPT_DIRLISTONLY, 1L);
	
	returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param2.setUTF8String(&dirlist);
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	
	returnValue.setReturn(pResult);
}

#pragma mark fileinfo

size_t curl_header_function_for_fileinfo(void *buffer,
																				 size_t size,
																				 size_t nmemb,
																				 CUTF8String& fileSize)
{
	size_t len = size * nmemb;
	std::string line = std::string((const char *)buffer, len);
	
	/* Reply format is like (File status)
	 213<space><size>
	 */
	
	if(line.find("213 ") == 0)
	{
		size_t length = line.length() -4;
		for(size_t i = length + 3; i > 0; --i)
		{
			if(line.compare(i, 1, "\n") == 0)
			{
				length--;continue;
			}
			if(line.compare(i, 1, "\r") == 0)
			{
				length--;continue;
			}
			break;
		}
		
		fileSize = CUTF8String((const uint8_t *)line.substr(4).c_str(), length);
	}
	
	return len;
}

void cURL_FTP_GetFileInfo(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param3.fromParamAtIndex(pParams, 3);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	curl_set_options(curl, Param1, userInfo, path);
	
	curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 1L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);
	
	curl_easy_setopt(curl, CURLOPT_FILETIME, 1L);
	
	/* header */
	CUTF8String fileSize;
	curl_easy_setopt(curl, CURLOPT_HEADERDATA, &fileSize);
	curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, curl_header_function_for_fileinfo);
	
	CURLcode result = curl_perform(mcurl, curl, Param3, userInfo);
	
	CUTF16String fileInfo;
	
	JSONNODE *info = json_new(JSON_NODE);
	
	if(result == CURLE_OK)
	{
		json_set_s_for_key(info, L"size", (const char *)fileSize.c_str());
		
		long _fileTime;
		if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &_fileTime))
		{
			char buf[80];
			time_t fileTime = (time_t)_fileTime;
			struct tm ts = *gmtime(&fileTime);
			strftime(buf, sizeof(buf), "%Y-%m-%dT%H:%M:%SZ", &ts);
			json_set_s_for_key(info, L"date", (const char *)buf);
		}
		json_stringify(info, fileInfo, FALSE);
		
		json_delete(info);
	}
	
	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param2.setUTF16String(&fileInfo);
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	
	returnValue.setIntValue(result);
	returnValue.setReturn(pResult);
}

#pragma mark system

size_t curl_header_function_for_system(void *buffer,
																			 size_t size,
																			 size_t nmemb,
																			 CUTF8String& system)
{
	size_t len = size * nmemb;
	std::string line = std::string((const char *)buffer, len);
	
	/* Reply format is like
	 215<space><OS-name><space><commentary>
	 */
	
	if(line.find("215 ") == 0)
	{
		size_t length = line.length() -4;
		for(size_t i = length + 3; i > 0; --i)
		{
			if(line.compare(i, 1, "\n") == 0)
			{
				length--;continue;
			}
			if(line.compare(i, 1, "\r") == 0)
			{
				length--;continue;
			}
			break;
		}
		
		system = CUTF8String((const uint8_t *)line.substr(4).c_str(), length);
	}
	
	return len;
}

void cURL_FTP_System(sLONG_PTR *pResult, PackagePtr pParams)
{
	C_TEXT Param1;
	C_TEXT Param2;
	C_TEXT Param3;
	C_LONGINT returnValue;
	
	Param1.fromParamAtIndex(pParams, 1);
	Param2.fromParamAtIndex(pParams, 2);
	Param3.fromParamAtIndex(pParams, 3);
	
	CURL *curl = curl_easy_init();
	CURLM *mcurl = gmcurl;//curl_multi_init();
	
	C_TEXT userInfo; /* PRIVATE */
	CUTF8String path;
	
	curl_set_options(curl, Param1, userInfo, path);

	curl_easy_setopt(curl, CURLOPT_NOBODY, 1L);
	curl_easy_setopt(curl, CURLOPT_HEADER, 0L);
	curl_easy_setopt(curl, CURLOPT_NOPROGRESS, 1L);

	/* header */
	CUTF8String system;
	curl_easy_setopt(curl, CURLOPT_HEADERDATA, &system);
	curl_easy_setopt(curl, CURLOPT_HEADERFUNCTION, curl_header_function_for_system);

	struct curl_slist *h = NULL;
	h = curl_slist_append(h, "SYST");

	curl_easy_setopt(curl, CURLOPT_PREQUOTE, h);
	
	returnValue.setIntValue(curl_perform(mcurl, curl, Param3, userInfo));
	
	curl_slist_free_all(h);
	
	curl_easy_cleanup(curl);
//	curl_multi_cleanup(mcurl);
	
	Param2.setUTF8String(&system);
	Param2.toParamAtIndex(pParams, 2);
	Param3.toParamAtIndex(pParams, 3);
	
	returnValue.setReturn(pResult);
}

#pragma mark JSON cURL

CURLoption json_get_curl_option_name(JSONNODE *n)
{
    std::lock_guard<std::mutex> lock(mutexJson);
    
	CURLoption v = (CURLoption)0;
	
	if(n)
	{
		v = (CURLoption)json_as_int(n);
		
		json_char *name = json_name(n);
		
		if (name)
		{
			std::wstring s = std::wstring((const wchar_t *)name);
			if (s.compare(L"VERBOSE") == 0)
			{
				v = CURLOPT_VERBOSE;goto json_get_curl_option_exit;
			}
			if (s.compare(L"USE_SSL") == 0)
			{
				v = CURLOPT_USE_SSL;goto json_get_curl_option_exit;
			}
			if (s.compare(L"URL") == 0)
			{
				v = CURLOPT_URL;goto json_get_curl_option_exit;
			}
			if (s.compare(L"USERNAME") == 0)
			{
				v = CURLOPT_USERNAME;goto json_get_curl_option_exit;
			}
			if (s.compare(L"PASSWORD") == 0)
			{
				v = CURLOPT_PASSWORD;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTPPORT") == 0)
			{
				v = CURLOPT_FTPPORT;goto json_get_curl_option_exit;
			}
			if (s.compare(L"APPEND") == 0)
			{
				v = CURLOPT_APPEND;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTP_ACCOUNT") == 0)
			{
				v = CURLOPT_FTP_ACCOUNT;goto json_get_curl_option_exit;
			}
			if (s.compare(L"PRIVATE") == 0)
			{
				v = CURLOPT_PRIVATE;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTP_USE_EPRT") == 0)
			{
				v = CURLOPT_FTP_USE_EPRT;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTP_USE_EPSV") == 0)
			{
				v = CURLOPT_FTP_USE_EPSV;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTP_USE_PRET") == 0)
			{
				v = CURLOPT_FTP_USE_PRET;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTP_ALTERNATIVE_TO_USER") == 0)
			{
				v = CURLOPT_FTP_ALTERNATIVE_TO_USER;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTP_FILEMETHOD") == 0)
			{
				v = CURLOPT_FTP_FILEMETHOD;goto json_get_curl_option_exit;
			}
			if (s.compare(L"TCP_KEEPALIVE") == 0)
			{
				v = CURLOPT_TCP_KEEPALIVE;goto json_get_curl_option_exit;
			}
			if (s.compare(L"TCP_KEEPIDLE") == 0)
			{
				v = CURLOPT_TCP_KEEPIDLE;goto json_get_curl_option_exit;
			}
			if (s.compare(L"TCP_KEEPINTVL") == 0)
			{
				v = CURLOPT_TCP_KEEPINTVL;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTP_RESPONSE_TIMEOUT") == 0)
			{
				v = CURLOPT_FTP_RESPONSE_TIMEOUT;goto json_get_curl_option_exit;
			}
			if (s.compare(L"CONNECTTIMEOUT") == 0)
			{
				v = CURLOPT_CONNECTTIMEOUT;goto json_get_curl_option_exit;
			}
			if (s.compare(L"TIMEOUT") == 0)
			{
				v = CURLOPT_TIMEOUT;goto json_get_curl_option_exit;
			}
			if (s.compare(L"LOW_SPEED_TIME") == 0)
			{
				v = CURLOPT_LOW_SPEED_TIME;goto json_get_curl_option_exit;
			}
			if (s.compare(L"LOW_SPEED_LIMIT") == 0)
			{
				v = CURLOPT_LOW_SPEED_LIMIT;goto json_get_curl_option_exit;
			}
			if (s.compare(L"SSL_VERIFYHOST") == 0)
			{
				v = CURLOPT_SSL_VERIFYHOST;goto json_get_curl_option_exit;
			}
			if (s.compare(L"SSL_VERIFYPEER") == 0)
			{
				v = CURLOPT_SSL_VERIFYPEER;goto json_get_curl_option_exit;
			}
			if (s.compare(L"CAINFO") == 0)
			{
				v = CURLOPT_CAINFO;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTPSSLAUTH") == 0)
			{
				v = CURLOPT_FTPSSLAUTH;goto json_get_curl_option_exit;
			}
			if (s.compare(L"FTP_SSL_CCC") == 0)
			{
				v = CURLOPT_FTP_SSL_CCC;goto json_get_curl_option_exit;
			}
			if (s.compare(L"SSH_AUTH_TYPES") == 0)
			{
				v = CURLOPT_SSH_AUTH_TYPES;goto json_get_curl_option_exit;
			}
			if (s.compare(L"SSH_COMPRESSION") == 0)
			{
				v = CURLOPT_SSH_COMPRESSION;goto json_get_curl_option_exit;
			}
			if (s.compare(L"SSH_HOST_PUBLIC_KEY_MD5") == 0)
			{
				v = CURLOPT_SSH_HOST_PUBLIC_KEY_MD5;goto json_get_curl_option_exit;
			}
			if (s.compare(L"SSH_PUBLIC_KEYFILE") == 0)
			{
				v = CURLOPT_SSH_PUBLIC_KEYFILE;goto json_get_curl_option_exit;
			}
			if (s.compare(L"SSH_PRIVATE_KEYFILE") == 0)
			{
				v = CURLOPT_SSH_PRIVATE_KEYFILE;goto json_get_curl_option_exit;
			}
			if (s.compare(L"SSH_KNOWNHOSTS") == 0)
			{
				v = CURLOPT_SSH_KNOWNHOSTS;goto json_get_curl_option_exit;
			}
			
		json_get_curl_option_exit:
			json_free(name);
		}
	}
	
	return v;
}

void json_get_curl_option_m(CURL *curl, CURLoption option, JSONNODE *n)
{
	if(n)
	{
		json_int_t v =  json_as_int(n);
		
		json_char *value = json_as_string(n);
		
		if(value)
		{
			std::wstring s = std::wstring((const wchar_t *)value);
			if (s.compare(L"PUBLICKEY") != std::string::npos)
			{
				v = v|CURLSSH_AUTH_PUBLICKEY;
			}
			if (s.compare(L"PASSWORD") != std::string::npos)
			{
				v = v|CURLSSH_AUTH_PASSWORD;
			}
			if (s.compare(L"HOST") != std::string::npos)
			{
				v = v|CURLSSH_AUTH_HOST;
			}
			if (s.compare(L"KEYBOARD") != std::string::npos)
			{
				v = v|CURLSSH_AUTH_KEYBOARD;
			}
			if (s.compare(L"AGENT") != std::string::npos)
			{
				v = v|CURLSSH_AUTH_AGENT;
			}
			
			json_free(value);
		}
		
		
		curl_easy_setopt(curl, option, value);
	}
}

void json_get_curl_option_c(CURL *curl, CURLoption option, JSONNODE *n)
{
	if(n)
	{
		json_int_t value = json_get_curl_option_value(n);
		curl_easy_setopt(curl, option, value);
	}
}

void json_get_curl_option_i(CURL *curl, CURLoption option, JSONNODE *n)
{
	if(n)
	{
		json_int_t value = json_as_int(n);
		curl_easy_setopt(curl, option, value);
	}
}

void json_get_curl_option_p(CURL *curl, CURLoption option, JSONNODE *n)
{
	if(n)
	{
		json_char *value = json_as_string(n);
		
		if(value)
		{
			CUTF8String u;
			json_wconv(value, &u);
#if VERSIONMAC
			/* hfs to posix */
			C_TEXT t;
			t.setUTF8String(&u);
			t.copyPath(&u);
#endif
			curl_easy_setopt(curl, option, u.c_str());
			json_free(value);
		}
	}
}

void json_get_curl_option_s(CURL *curl, CURLoption option, JSONNODE *n, CUTF8String& path)
{
	if(n)
	{
		json_char *value = json_as_string(n);
		
		if(value)
		{
			CUTF8String u;
			json_wconv(value, &u);
			curl_easy_setopt(curl, option, u.c_str());
			if(option == CURLOPT_URL)
			{
				size_t pos = u.find((const uint8_t *)"://");
				if(pos != std::string::npos)
				{
					u = u.substr(pos + 4);//strlen("://")++
				}
				pos = u.find((const uint8_t *)"/");
				if(pos != std::string::npos)
				{
					path = u.substr(pos + 1);//++
				}
			}
			json_free(value);
		}
	}
}

long json_get_curl_option_value(JSONNODE *n)
{
	long v = json_as_int(n);
	
	json_char *value = json_as_string(n);
	
	if(value)
	{
		std::wstring s = std::wstring((const wchar_t *)value);
		if (s.compare(L"MULTICWD") == 0)
		{
			v = CURLFTPMETHOD_MULTICWD;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"NOCWD") == 0)
		{
			v = CURLFTPMETHOD_NOCWD;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"SINGLECWD") == 0)
		{
			v = CURLFTPMETHOD_SINGLECWD;goto json_get_curl_option_value_exit;
		}

		if (s.compare(L"AUTH_DEFAULT") == 0)
		{
			v = CURLFTPAUTH_DEFAULT;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"AUTH_SSL") == 0)
		{
			v = CURLFTPAUTH_SSL;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"AUTH_TLS") == 0)
		{
			v = CURLFTPAUTH_TLS;goto json_get_curl_option_value_exit;
		}

		if (s.compare(L"CCC_NONE") == 0)
		{
			v = CURLFTPSSL_CCC_NONE;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"CCC_PASSIVE") == 0)
		{
			v = CURLFTPSSL_CCC_PASSIVE;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"CCC_ACTIVE") == 0)
		{
			v = CURLFTPSSL_CCC_ACTIVE;goto json_get_curl_option_value_exit;
		}
		
		if (s.compare(L"USESSL_NONE") == 0)
		{
			v = CURLUSESSL_NONE;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"USESSL_TRY") == 0)
		{
			v = CURLUSESSL_TRY;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"USESSL_CONTROL") == 0)
		{
			v = CURLUSESSL_CONTROL;goto json_get_curl_option_value_exit;
		}
		if (s.compare(L"USESSL_ALL") == 0)
		{
			v = CURLUSESSL_ALL;goto json_get_curl_option_value_exit;
		}
		
	json_get_curl_option_value_exit:
		json_free(value);
	}
	
	return v;
}

#pragma mark -

protocol_type_t curl_set_options(CURL *curl, C_TEXT& Param1, C_TEXT& userInfo, CUTF8String& path)
{
	protocol_type_t protocol = PROTOCOL_TYPE_UNKNOWN;
	
	CUTF8String Param1_u8;
	Param1.copyUTF8String(&Param1_u8);
	std::wstring Param1_option;
	json_wconv((const char *)Param1_u8.c_str(), Param1_option);
	JSONNODE *option = json_parse(Param1_option.c_str());
	if(option)
	{
		if (json_type(option) == JSON_NODE)
		{
			JSONNODE_ITERATOR i = json_begin(option);
			while (i != json_end(option))
			{
				CURLoption curl_option = json_get_curl_option_name(*i);
				switch (curl_option)
				{
					case CURLOPT_PRIVATE:
					{
						json_char *value = json_as_string(*i);
						if(value)
						{
							CUTF8String u;
							json_wconv(value, &u);
							userInfo.setUTF8String(&u);
							json_free(value);
						}
					}
						break;
						
						/* char */
					case CURLOPT_USERNAME:
					case CURLOPT_PASSWORD:
					case CURLOPT_URL:
					case CURLOPT_FTPPORT:
					case CURLOPT_FTP_ACCOUNT:
					case CURLOPT_FTP_ALTERNATIVE_TO_USER:
					case CURLOPT_SSH_HOST_PUBLIC_KEY_MD5:
						json_get_curl_option_s(curl, curl_option, *i, path);
						if(curl_option == CURLOPT_URL)
						{
							json_char *value = json_as_string(*i);
							if(value)
							{
								CUTF8String u;
								json_wconv(value, &u);
								if(0 == u.find((const uint8_t *)"sftp:"))
								{
									protocol = PROTOCOL_TYPE_SFTP;
								}
								
								if(0 == u.find((const uint8_t *)"ftps:"))
								{
									protocol = PROTOCOL_TYPE_FTPS;
								}
								json_free(value);
							}
						}
						break;
						
						/* path */
					case CURLOPT_CAINFO:
					case CURLOPT_SSH_PUBLIC_KEYFILE:
					case CURLOPT_SSH_PRIVATE_KEYFILE:
					case CURLOPT_SSH_KNOWNHOSTS:
						json_get_curl_option_p(curl, curl_option, *i);
						break;
						
						/* long */
					case CURLOPT_VERBOSE:
					case CURLOPT_APPEND:
					case CURLOPT_FTP_USE_EPRT:
					case CURLOPT_FTP_USE_EPSV:
					case CURLOPT_FTP_USE_PRET:
					case CURLOPT_TCP_KEEPALIVE:
					case CURLOPT_TCP_KEEPIDLE:
					case CURLOPT_TCP_KEEPINTVL:
					case CURLOPT_FTP_RESPONSE_TIMEOUT:
					case CURLOPT_CONNECTTIMEOUT:
					case CURLOPT_TIMEOUT:
					case CURLOPT_LOW_SPEED_TIME:
					case CURLOPT_LOW_SPEED_LIMIT:
					case CURLOPT_SSL_VERIFYHOST:
					case CURLOPT_SSL_VERIFYPEER:
					case CURLOPT_SSH_COMPRESSION:
						json_get_curl_option_i(curl, curl_option, *i);
						break;
						
						/* constant or long */
					case CURLOPT_FTP_FILEMETHOD:
					case CURLOPT_FTPSSLAUTH:
					case CURLOPT_FTP_SSL_CCC:
					case CURLOPT_USE_SSL:
						json_get_curl_option_c(curl, curl_option, *i);
						break;
						
						/* constant bit mask or long */
					case CURLOPT_SSH_AUTH_TYPES:
						json_get_curl_option_m(curl, curl_option, *i);
						break;
						
					default:
						break;
				}
				
				++i;
			}
			
		}
		json_delete(option);
	}

	return protocol;
}

void curl_get_info(CURL *curl, CUTF16String& json)
{
	long responseCode, connectCode, fileTime, redirectCount, headerSize, requestSize, lastSocket;
	long sslVerifyResult, localPort, primaryPort, numConnects, osErrNo, httpAuthAvail, proxyAuthAvail;
	double totalTime, nameLookupTime, connectTime, appConnectTime, preTransferTime, startTransferTime, redirectTime;
	double sizeUpload, speedUpload, sizeDownload, speedDownload, contentLengthDownload, contentLengthUpload;
	long rtspClientCseq, rtspServerCseq, rtspCseqRecv, conditionUnmet;
	char *effectiveUrl = NULL;
	char *redirectUrl = NULL;
	char *contentType = NULL;
	char *ftpEntryPath = NULL;
	char *localIp = NULL;
	char *primaryIp = NULL;
	char *rtspSessionId = NULL;
    
    std::lock_guard<std::mutex> lock(mutexJson);
	
	JSONNODE *info = json_new(JSON_NODE);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONDITION_UNMET, &conditionUnmet))
		json_set_i_for_key(info, L"conditionUnmet", conditionUnmet);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_UPLOAD, &contentLengthUpload))
		json_set_i_for_key(info, L"contentLengthUpload", contentLengthUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CLIENT_CSEQ, &rtspClientCseq))
		json_set_i_for_key(info, L"rtspClientCseq", rtspClientCseq);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SERVER_CSEQ, &rtspServerCseq))
		json_set_i_for_key(info, L"rtspServerCseq", rtspServerCseq);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_CSEQ_RECV, &rtspCseqRecv))
		json_set_i_for_key(info, L"rtspCseqRecv", rtspCseqRecv);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LASTSOCKET, &lastSocket))
		json_set_i_for_key(info, L"lastSocket", lastSocket);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_PORT, &primaryPort))
		json_set_i_for_key(info, L"primaryPort", primaryPort);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_PORT, &localPort))
		json_set_i_for_key(info, L"localPort", localPort);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &contentLengthDownload))
		json_set_i_for_key(info, L"contentLengthDownload", contentLengthDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTP_CONNECTCODE, &connectCode))
		json_set_i_for_key(info, L"connectCode", connectCode);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FILETIME, &fileTime))
		json_set_i_for_key(info, L"fileTime", fileTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_TOTAL_TIME, &totalTime))
		json_set_i_for_key(info, L"totalTime", totalTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REQUEST_SIZE , &requestSize))
		json_set_i_for_key(info, L"requestSize", requestSize);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HEADER_SIZE, &headerSize))
		json_set_i_for_key(info, L"headerSize", headerSize);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_UPLOAD, &speedUpload))
		json_set_i_for_key(info, L"speedUpload", speedUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SPEED_DOWNLOAD, &speedDownload))
		json_set_i_for_key(info, L"speedDownload", speedDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_DOWNLOAD, &sizeDownload))
		json_set_i_for_key(info, L"sizeDownload", sizeDownload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SIZE_UPLOAD, &sizeUpload))
		json_set_i_for_key(info, L"sizeUpload", sizeUpload);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_HTTPAUTH_AVAIL, &httpAuthAvail))
		json_set_i_for_key(info, L"httpAuthAvail", httpAuthAvail);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PROXYAUTH_AVAIL, &proxyAuthAvail))
		json_set_i_for_key(info, L"proxyAuthAvail", proxyAuthAvail);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_OS_ERRNO, &osErrNo))
		json_set_i_for_key(info, L"osErrNo", osErrNo);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NUM_CONNECTS, &numConnects))
		json_set_i_for_key(info, L"numConnects", numConnects);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE, &responseCode))
		json_set_i_for_key(info, L"responseCode", responseCode);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_NAMELOOKUP_TIME, &nameLookupTime))
		json_set_i_for_key(info, L"nameLookupTime", nameLookupTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONNECT_TIME, &connectTime))
		json_set_i_for_key(info, L"connectTime", connectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_APPCONNECT_TIME, &appConnectTime))
		json_set_i_for_key(info, L"appConnectTime", appConnectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRETRANSFER_TIME, &preTransferTime))
		json_set_i_for_key(info, L"preTransferTime", preTransferTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_STARTTRANSFER_TIME, &startTransferTime))
		json_set_i_for_key(info, L"startTransferTime", startTransferTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_TIME, &redirectTime))
		json_set_i_for_key(info, L"redirectTime", redirectTime);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_SSL_VERIFYRESULT , &sslVerifyResult))
		json_set_i_for_key(info, L"sslVerifyResult", sslVerifyResult);
	
	if(CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_COUNT, &redirectCount))
		json_set_i_for_key(info, L"redirectCount", redirectCount);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_EFFECTIVE_URL, &effectiveUrl)))
		json_set_s_for_key(info, L"effectiveUrl", effectiveUrl);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_LOCAL_IP, &localIp)))
		json_set_s_for_key(info, L"localIp", localIp);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_CONTENT_TYPE, &contentType)))
		json_set_s_for_key(info, L"contentType", contentType);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_PRIMARY_IP, &primaryIp)))
		json_set_s_for_key(info, L"primaryIp", primaryIp);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_REDIRECT_URL, &redirectUrl)))
		json_set_s_for_key(info, L"redirectUrl", redirectUrl);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_FTP_ENTRY_PATH, &ftpEntryPath)))
		json_set_s_for_key(info, L"ftpEntryPath", ftpEntryPath);
	
	if((CURLE_OK == curl_easy_getinfo(curl, CURLINFO_RTSP_SESSION_ID, &rtspSessionId)))
		json_set_s_for_key(info, L"rtspSessionId", rtspSessionId);
	
	json_stringify(info, json, FALSE);

	json_delete(info);
}

void last_path_component(CUTF8String& path)
{
	size_t pos = path.length() -1;
	size_t end = pos;
	size_t len = pos - 1;
	
	for(size_t i = pos; i > 0; --i)
	{
		if((path.compare(i, 1, (const uint8_t *)"/") == 0) && (i == end))
		{
			pos--;len--;continue;
		}
		if(path.compare(i, 1, (const uint8_t *)"/") != 0)
		{
			pos--;continue;
		}
		len++;break;
	}
	
	path = path.substr(pos + 1, len - pos);
}

void remove_trailing_separator(CUTF8String& path)
{
	size_t pos = path.length() -1;
	
	if((path.compare(pos, 1, (const uint8_t *)"/") == 0))
	{
		path = path.substr(0, pos);
	}
	
}

void remove_trailing_separator(CUTF16String& path)
{
	size_t pos = path.length() -1;
	
	if((path.compare(pos, 1, (const PA_Unichar *)L"\\") == 0))
	{
		path = path.substr(0, pos);
	}
	
}

void curl_unescape_path(CURL *curl, CUTF8String& path)
{
	int ftp_path_len = 0;
	char *ftp_path = curl_easy_unescape(curl, (const char *)path.c_str(), path.length(), &ftp_path_len);
	path = CUTF8String((const uint8_t *)ftp_path, ftp_path_len);
	curl_free(ftp_path);
}
